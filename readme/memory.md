了解しました！

以下の内容について詳しく調査し、お伝えします。

- 一般的なメモリの動作原理（ガベージコレクション、ヒープ/スタックメモリ）
- Chrome と Edge のメモリ管理の違い
- NgRx とメモリ消費の関係（メモリリーク対策、最適化）
- 開発者ツールを使ったメモリの監視方法
- コンポーネント単体の状態管理とグローバルな状態管理のメモリや CPU の処理の違い
- ブラウザのメモリの許容量と PC スペック依存の場合の計算式

調査が完了次第、詳細をお伝えします！

# NgRx のメモリ消費とブラウザのメモリ管理に関する調査レポート

## 一般的なメモリの動作原理

### ガベージコレクションの仕組み

JavaScript などの高水準言語では、オブジェクト生成時に必要なメモリを自動で確保し、不要になれば自動で解放する「ガベージコレクション (GC)」によるメモリ管理が行われます ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。GC の代表的なアルゴリズムである**マークアンドスイープ (mark-and-sweep)**法では、「到達不能(どの変数からも参照されなくなった)オブジェクト」を**不要なオブジェクト**とみなし、メモリから回収します ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0))。現在の全ての主要な JavaScript エンジンはマークアンドスイープ方式の GC を搭載しており、**世代別 GC**・**インクリメンタル GC**・**並行 GC**などの手法で効率や停止時間の改善が図られています ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82))。世代別 GC では生成後間もなく消えるオブジェクトと長寿命のオブジェクトを分けて管理し、若い世代を高頻度で収集することで効率化します。このように自動 GC により開発者が明示的にメモリ解放する必要はありませんが、**「参照」が残っている限り GC は解放できない**ため、コードの不備でオブジェクトへの参照が残り続けるとメモリリークが発生します ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82)) ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。例えばグローバル変数に不要なオブジェクトを保持したままにしたり、イベントリスナーの登録解除漏れで DOM 要素への参照が残るケースなどでは、GC が対象と判断できずメモリ上にオブジェクトが残り続けてしまいます。

### ヒープメモリとスタックメモリの違い

プログラムが使用するメモリ領域には大きく分けて**スタック**と**ヒープ**があります。**スタック**は関数呼び出しやローカル変数など一時的なデータ用の領域で、固定長のデータを後入れ先出し（LIFO）で管理します。例えば JavaScript エンジンは、コンパイル時点でサイズが確定するプリミティブ値（数値・文字列・真偽値など）やオブジェクトへの参照をスタック領域に割り当てます ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%8C%E6%B1%BA%E3%81%BE%E3%82%8B%E5%80%A4%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%81%AF%E3%80%81%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A1%8C%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%9D%99%E7%9A%84%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%A8%E3%82%82%E8%A8%80%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%20%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E3%81%AB%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%8C%E6%B1%BA%E3%81%BE%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%97%E3%81%A6%E3%80%81%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B,Last%20In%20First%20Out))。スタック領域は高速にアクセスできますが各データのサイズが固定であり、関数の終了とともに自動的に解放されます。一方、**ヒープ**は動的にサイズが決まるオブジェクトを格納するための大きな領域で、構造が柔軟な分アクセスはスタックより遅くなります ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%AF%E3%80%81%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E7%95%B0%E3%81%AA%E3%82%8A%E3%80%81%E6%A7%8B%E9%80%A0%E5%8C%96%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82))。JavaScript では**オブジェクトや配列、関数の実体はヒープ領域に確保され、その参照（ポインタ）だけがスタックに置かれる**という形をとります ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E3%81%82%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AF%E5%A4%89%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%80%81JavaScript%20%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%81%AF%E5%90%84%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E5%9B%BA%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82%E4%B8%80%E6%96%B9%E3%80%81%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%20%E3%81%AB%E3%81%82%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AF%E5%8F%AF%E5%A4%89%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E5%9B%BA%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E3%81%9B%E3%81%9A%E3%80%81%E5%BF%85%E8%A6%81%E3%81%AB%E5%BF%9C%E3%81%98%E3%81%9F%E5%A4%9A%E3%82%81%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82)) ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=match%20at%20L210%20%E9%96%A2%E6%95%B0%E3%82%84%E9%85%8D%E5%88%97%E3%82%82%E5%90%8C%E6%A7%98%E3%81%AB%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A7%E3%80%81%E5%AE%9F%E4%BD%93%E3%81%8C%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%E3%81%AB%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%80%81%E5%AE%9F%E6%85%8B%E3%81%AE%E5%8F%82%E7%85%A7%E3%81%8C%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%20%E4%B8%80%E6%96%B9%E3%80%81%E6%96%87%E5%AD%97%E5%88%97%E3%82%84%E6%95%B0%E5%80%A4%E7%AD%89%E3%81%AE%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B%E3%82%92%E5%AE%A3%E8%A8%80%E3%81%97%E3%81%9F%E6%99%82%E3%80%81JavaScript,%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%81%AF%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A1%8C%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。例えばオブジェクトを生成すると、その内容はヒープ上に配置され、スタック上の変数にはヒープ上のオブジェクトへの参照が格納されます。このようにスタックとヒープで役割が異なり、スタックは固定サイズで高速・自動解放、ヒープは可変サイズで GC による管理といった特徴があります。

### JavaScript におけるメモリ管理の特徴

JavaScript は上述のとおり**自動メモリ管理**の言語であり、低レベル言語のように開発者が`malloc`や`free`を直接呼び出す必要がありません ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。これはメモリリークのリスクを減らす利点がありますが、「自動だからメモリ管理を気にしなくてよい」というわけではありません ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AB%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%82%92%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%AB%E7%A2%BA%E4%BF%9D%E3%81%97%E3%80%81%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%82%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%82%92%E8%A7%A3%E6%94%BE%E3%81%97%E3%81%BE%E3%81%99%EF%BC%88%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%80%82%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E6%80%A7%E3%81%8C%E6%B7%B7%E4%B9%B1%E3%81%AE%E5%85%83%E3%81%AB%E3%81%AA%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%83%A1%E3%83%A2%20%E3%83%AA%E3%83%BC%E7%AE%A1%E7%90%86%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E5%BF%83%E9%85%8D%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%AA%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E8%AA%A4%E3%81%A3%E3%81%9F%E5%8D%B0%E8%B1%A1%E3%82%92%E9%96%8B%E7%99%BA%E8%80%85%E3%81%AB%E4%B8%8E%E3%81%88%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。実際には**プログラム上から参照が消えない限りメモリは解放されない**ため、意図的に不要になったオブジェクトへの参照を断つ工夫が必要です。例えば、不要になったイベントリスナーやタイマーは明示的に解除し、閉じた画面のデータをグローバルストアに保持し続けないようにするなど、**開発者側で「オブジェクトへの参照を適切にスコープから除去する」ことがメモリリーク対策になります**。JavaScript にも`WeakMap`や`WeakRef`といった弱い参照を扱う仕組みがあり、これらは対象が他から参照されなくなれば自動的に破棄される性質を持つため、メモリリークを防ぐ用途で活用できます。総じて、JavaScript のメモリ管理は自動 GC により簡便ですが、根本的なメモリリークの原因（不要な参照が残ること）を防ぐよう設計・コーディングすることが重要です。

## Chrome と Edge のメモリ管理の違い

([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/)) _図: Chrome/Edge のマルチプロセスアーキテクチャ概念図。ブラウザの UI を管理する**ブラウザプロセス**、描画用の**GPU プロセス**、各タブの内容を処理する**レンダラープロセス**、拡張機能用プロセス、プラグイン用プロセスなどに分離されている。プロセス分離により、あるタブがクラッシュしても他のタブやブラウザ本体に影響しないようになっている。_

Chrome は当初より**マルチプロセス構造**を採用しており、各タブ（レンダラ）やプラグインをブラウザ本体とは別のプロセスで動作させます。これにより、あるタブのレンダリングエンジンがクラッシュしてもブラウザ全体や他のタブが巻き添えで落ちることはなく、動作の安定性と応答性が向上します ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。またプロセスが分離されていることでセキュリティ面でも効果があり、レンダラプロセスをサンドボックス化して悪意あるコードの影響をブラウザ全体に及ばないようにしています ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。Chrome は内部にタスクマネージャを備えており、各タブや拡張機能ごとのメモリ消費量や CPU 使用率を確認したり、応答しないプロセスを個別に終了させることができます ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Interestingly%2C%20using%20multiple%20processes%20means,to%20restart%20the%20entire%20browser))。これはプロセスごとにリソースを隔離しているマルチプロセス構造の利点の一つです。

現在の**Microsoft Edge (Chromium 版)**も基本的に Chrome と同じ Blink レンダリングエンジン/V8 実行環境を使用しており、アーキテクチャもマルチプロセス構造です。Edge では各タブを別々のレンダラープロセスとして分離するだけでなく、ページ内に埋め込まれた広告などの**サブフレーム**についても別プロセスに分離する仕組みを持っています ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。例えば Edge では、4 つのタブを開きそれぞれに広告フレームが含まれる場合、タブ本体用のレンダラープロセス 4 つに加え、広告フレーム用のレンダラープロセスがドメインごとに 2 つ立ち上がり、合計 6 つのレンダラープロセスが動作すると報告されています ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。もっとも Chrome もサイトアイソレーションの強化により、異なるドメインの iframe を別プロセスにする動作が導入されており、プロセス分割の方針は両者で似通ってきています。いずれにせよ、Chrome/Edge ともにタブ単位でプロセスを独立させることで**タブごとのリソース管理**を行っており、不要になったタブを閉じればそのプロセスごと OS に回収させることでメモリを解放できます。この設計により、仮に特定のタブで JavaScript のメモリリークが起きても、そのタブを閉じればメモリは完全に解放され、他のタブに影響を残さないという利点があります。

メモリリークやメモリ過剰使用への対策として、**Edge**には「**スリープタブ** (Sleeping Tabs)」という独自機能があります。一定時間操作されていない非アクティブなタブを自動的に休眠状態にし、メモリや CPU リソースの消費を大幅に削減する仕組みです ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Sleeping%20Tabs%20is%20not%20a,you%20left%20off%20without%20delay))。Microsoft によれば、このスリープタブ機能によって「平均で 85%のメモリと 99%の CPU 資源を節約できる」と報告されています ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。スリープ状態になったタブは内部的にページのスクリプト実行が停止され、一部メモリが解放されますが、タブ自体は維持されているため再びアクティブにした際の復元が高速です ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))。Edge ではユーザーが設定でスリープまでの待機時間を変更したり、特定のサイトをスリープ除外リストに登録するといった細かな制御も可能です ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Microsoft%20has%20been%20building%20out,which%20is%20critical%20for%20laptops)) ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=1,System%20and%20performance))。一方、**Chrome**にもメモリ不足時にバックグラウンドタブを一時的にメモリから外す「タブの破棄 (Tab Discarding)」機能が以前から存在し、最近では Chrome 108 以降で Edge に類似した「メモリセーバー」機能も正式に導入されました。この機能では一定時間非使用のタブを自動休止させ、アクティブ時に再読み込みして復元することでメモリ使用量を抑えています。Chrome の従来のタブ破棄はシステムメモリが逼迫した際に OS に通知して未使用タブを完全にメモリから開放する仕組みでした ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))（復帰時には再度ネットワークからページを読み込む必要がある）。新しいメモリセーバーではユーザーが任意に機能をオン/オフできる点など Edge のスリープタブに近い動作になっています ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Despite%20Sleeping%20Tabs%20being%20built,based%20on%20system%20RAM%20levels))。このように**非アクティブタブのリソース開放**に関しては、Edge が先行していた分野に Chrome も追随しつつあり、両ブラウザのメモリ最適化機能は近年収束しつつあります。

以上を踏まえ、Chrome と Edge (Chromium) のメモリ管理の相違点をまとめると次の表のようになります。

| **項目**                  | **Google Chrome**                                                           | **Microsoft Edge** |
| ------------------------- | --------------------------------------------------------------------------- | ------------------ |
| **エンジン/プロセス構造** | Chromium エンジン (Blink/V8)。初期からマルチプロセスアーキテクチャを採用 ([ |

Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。<br>ブラウザ、GPU、各タブ（レンダラ）、プラグイン、拡張機能ごとに独立プロセス。 | Chromium エンジン (Blink/V8)。Chromium 版(現在)は Chrome 同等のマルチプロセス構造 ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。<br>タブに加え広告フレームなどサブコンポーネントも別プロセス化。 |
| **メモリ使用傾向** | 多数のプロセスを生成するためメモリ消費は大きいが、高速化の最適化も継続。 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))のテストでは 6 ページ同時表示で**約 1.4GB**使用。 | 同じ Chromium ベースでも独自最適化でメモリ効率が良いとの報告あり。 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))の同条件テストでは**約 665MB**と Chrome の半分以下だった。 |
| **非アクティブタブの扱い** | 従来はメモリ逼迫時に非表示タブを**破棄**しメモリ解放（再表示時に再読み込み） ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))。<br>2022 年以降は**メモリセーバー**機能により一定時間非使用タブを休止状態にしてリソース節約（ユーザー設定可能）。 | **スリープタブ**機能により一定時間非操作のタブを自動休眠し、平均でメモリ 85%削減 ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。復帰も即座に可能。<br>また「効率モード」でバッテリー残量低下時等にタブ休眠を積極化する機能も搭載。 |
| **メモリリーク対策** | タブ毎のプロセス隔離により、一つのタブ内でリークが起きても他に影響せず、タブを閉じれば OS が全メモリ回収。<br>DevTools のメモリプロファイラでリーク検出・解消が可能（後述）。 | Chrome 同様のプロセス隔離による局所化。タブ休眠機能で長時間開きっぱなしのタブによるメモリ浪費を防止。<br>開発者ツールも Chromium ベースで同等のメモリ分析機能を提供。 |
| **開発者向けツール** | Chrome DevTools に「Memory」パネルがありヒープスナップショットや割り当てタイムラインでメモリを詳細分析可能。 ([Memory panel overview  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory#:~:text=The%20Memory%20panel%20provides%20diagnostic,allocation%20by%20function%2C%20and%20more)) | Edge も DevTools は Chrome と同一基盤のため「メモリ」タブで同様のプロファイルが可能。<br>Edge 独自機能としてタスクマネージャやスリープタブの効果を可視化するグラフ表示などがある。 |

_表: Chrome と Edge (Chromium 版) におけるメモリ管理の比較 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023)) ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless)) ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))_

## NgRx とメモリ消費の関係

### グローバル状態管理によるメモリ使用量

NgRx は Redux パターンに基づく**グローバル状態管理**ライブラリであり、アプリ全体の状態を単一の大きな JavaScript オブジェクト（**ストア**）で管理します。ストアに保持された状態はメモリ上に常駐するため、その内容が増大すればアプリのメモリ使用量も増加します。必要以上に大量のデータをストアに保持し続けることは**「過剰な状態保持」**となり、メモリフットプリント肥大化の原因となります。例えば本来一画面でしか使わない一時的なデータまでもグローバルストアに保存し続けると、ユーザーが画面遷移して使わなくなった後もメモリを圧迫し続けることになります。また NgRx ストアは基本的にアプリ実行中は保持され続けるため、アプリの稼働時間が長くなるシナリオ（SPA を長時間リロードせず使う等）では、使い終わったデータを明示的に削除しない限りメモリ使用量が蓄積する傾向があります。このため、必要なデータだけを適切な**スライス（部分領域）**に分割して管理し、不要になったらストアから削除する工夫が重要です。

また NgRx では状態変更のたびに**Immutable（不変）な新オブジェクト**を生成するため、古いオブジェクトへの参照がどこにもなくなれば GC で回収されます。しかし、Redux DevTools 拡張などで状態の履歴を大量に保持していると開発時にメモリを多く消費する場合があります（本番ビルドでは通常履歴保持しないので問題ありません）。いずれにせよ、NgRx 自体はメモリリークを起こさないよう設計されていますが、その**使い方次第でメモリ消費が大きく変わる**点に注意が必要です。

### メモリリークの原因（購読の解除忘れ等）

NgRx によるメモリリークでもっとも多い原因は、**ストアからの状態購読(Subscription)管理ミス**です。コンポーネントで`this.store.select(...).subscribe(...)`のようにストアの Observable を購読した場合、コンポーネントが破棄されても購読を解除(`unsubscribe`)しない限り、ストアから値が流れ続けます。解除漏れがあると、不要になったコンポーネントやその変数がストアの Observable 経由で参照され続け、GC で回収されずにメモリに残ってしまいます。これが**メモリリーク**につながります ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。対策として、Angular コンポーネントの`OnDestroy`で確実に`unsubscribe`するか、`takeUntil`演算子や`AsyncPipe`を用いて自動的に購読解除する仕組みにすることが重要です ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。例えば、`AsyncPipe`を使えばテンプレート上でストアの Observable を直接バインドでき、コンポーネント破棄時に Angular が自動で購読解除してくれます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。

もう一つのリーク要因は**不要な状態をストアに残し続けること**です。特に配列やオブジェクトの大量データをストアに保持している場合、画面遷移で使わなくなったら明示的にそれらをクリアするアクションを dispatch するのが望ましいです。NgRx 自体は単一のストアオブジェクトを常に参照し続けるため、ストアからデータを削除しない限りメモリ上に居座ります。例えば大量の一覧データを取得してストアに保存したままにすると、ユーザーが別機能に移動してその一覧を見ていなくてもメモリを消費し続けます。**メモリリーク**という厳密な意味では「不要な参照が残り続けること」ですが、NgRx では**使わないデータを解放し忘れる論理的リーク**にも注意が必要です。

### NgRx のメモリ最適化手法

NgRx を効率的に利用するためには、以下のようなメモリ最適化の手法が有効です。

- **ストアのスライス設計と Lazy Loading**: アプリ状態を機能ごとのスライス（区画）に分割し、必要なときにだけロードするようにします。Angular の Lazy Load 機能と NgRx を組み合わせ、遷移時に対応するリデューサーと状態を動的に追加することで、使っていない機能の状態をメモリに載せない工夫ができます。例えば、大規模アプリでユーザー設定機能のモジュールを Lazy Load にしておけば、ユーザー設定画面を開くまでその状態スライスはストアに存在せずメモリを節約できます。将来的に NgRx ではストアから状態スライスを削除する仕組み（動的に reducer を外す）が提供されつつあり、不要領域のメモリを開放できる可能性もあります。

- **コンポーネント単位の状態管理の活用**: 全てをグローバルストアで管理せず、コンポーネント内部の`ComponentStore`（NgRx ComponentStore モジュール）や単純なサービス＋ BehaviorSubject で局所的に状態管理するのも有効です。局所状態であればコンポーネント破棄時に自動的にメモリが開放され、グローバルに残るデータを減らせます。特に UI の一時的な表示状態（開閉フラグなど）やフォーム入力値などはグローバルに持たずローカル状態で十分です。

- **変更検知戦略 OnPush の利用**: Angular コンポーネントを`ChangeDetectionStrategy.OnPush`に設定することで、不必要な再レンダリングを減らしパフォーマンスを向上できます。直接的なメモリ削減策ではありませんが、OnPush により不要な差分計算やコンポーネント生成が抑制されるため、結果的にガベージコレクタの負担軽減や一時オブジェクトの削減につながります。また OnPush と NgRx は相性が良く、ストアからの状態変更通知を`AsyncPipe`で受け取る場合は自動的に OnPush でも変化検知されるため、効率的な UI 更新が可能です。

- **RxJS 演算子による購読数削減**: NgRx のセレクタを複数箇所で利用する際に、`shareReplay`などを使って Observable を共有化することで無駄な計算やメモリ使用を減らせます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=const%20s%20%3D%20new%20Subject)) ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=If%20you%20subscribe%20to%20,operators))。例えば同じ`select`結果を複数回`subscribe`するとその分オブジェクトが生成されますが、`share()`を挟めば一度の計算結果を使い回せます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=If%20you%20subscribe%20to%20,operators))。これにより不要なオブジェクトインスタンスの乱立を防ぎ、メモリ効率を上げることができます。

以上のように、NgRx 利用時は**「どの状態をどこまで保持するか」**を適切に設計し、RxJS 購読の寿命管理を徹底することが重要です。適切に実装すれば NgRx 自体が大きなメモリ負荷やリークの原因になることはなく、アプリの状態を一元管理しつつ健全なメモリ使用量を維持できます。

## 開発者ツールを使ったメモリの監視方法

### Chrome DevTools でのメモリプロファイリング

Chrome が提供する**DevTools**には強力なメモリ診断ツールが含まれています。DevTools の「**Memory**」パネルでは、ヒープメモリ内訳のスナップショット取得やメモリ割り当て状況のタイムライン記録などを行え、JavaScript オブジェクトのメモリ分布を分析して**メモリリークの発見と特定**ができます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E5%88%86%E5%B8%83%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%AE%E6%A4%9C%E5%87%BA%E3%81%A8%E5%88%86%E9%9B%A2%E3%80%81%E9%96%A2%E6%95%B0%E3%81%94%E3%81%A8%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%AE%E5%86%85%E8%A8%B3%E3%81%AE%E5%8F%96%E5%BE%97%E3%81%AA%E3%81%A9%E3%82%92%E8%A1%8C%E3%81%86%E8%A8%BA%E6%96%AD%E3%83%84%E3%83%BC%E3%83%AB%E3%81%8C%E7%94%A8%E6%84%8F%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。代表的な機能は次のとおりです ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82)):

- **Heap Snapshot (ヒープスナップショット)** – ヒープ内のオブジェクトと DOM ノードのメモリ使用状況を記録し、種類ごとのメモリ占有量を表示します。スナップショット間の**比較**機能もあり、特定の操作前後でオブジェクト数やメモリサイズの増減を比較することでリークしているオブジェクトを絞り込めます ([Record heap snapshots  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots#:~:text=compare%20snapshots%2C%20and%20find%20memory,information%2C%20see%20Objects%20retaining%20tree))。

- **Allocation Timeline (割り当てタイムライン)** – 一定期間のメモリアロケーション（割り当て）イベントを記録し、時間経過に沿ったメモリ使用量の推移を表示します。特定の時間区間を選択すると、その間に確保され、記録終了時点まで生存しているオブジェクトを抽出できます。これにより**どの操作で確保されたオブジェクトが解放されず残っているか**を特定し、メモリリークを隔離するのに役立ちます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82))。

- **Allocation Sampling (割り当てサンプリング)** – メモリ割り当てをサンプリングベースで記録する軽量プロファイルです。長時間動作する処理でもオーバーヘッド低く測定でき、関数ごとのメモリ割り当て状況を大まかに把握できます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82))。

- **Detached Elements (デタッチされた要素)** – メモリ上に残っているが DOM ツリー上は外された（いわゆる「死んだ」）DOM 要素を一覧表示します。イベントリスナーなどどこかで参照されているため GC されていない要素を検出でき、典型的なメモリリーク（削除したはずの DOM がメモリから消えていない）の発見に有用です。

Chrome DevTools を用いた基本的なメモリリーク調査手順は以下のようになります：

1. **ベースラインの取得** – 問題となるページを開いた状態で Memory パネルからヒープスナップショットを 1 回取得します。まず強制 GC（ごみ箱アイコン）を実行して不要メモリを可能な限り回収した上でスナップショットを取り、これをベースラインとします。

2. **操作の実行** – 次に調査したい操作（例：画面遷移を何度も繰り返す、データをロードするなど）を行い、メモリ使用量が増加する状況を作ります。操作中のメモリアロケーションを記録したい場合、Allocation Timeline を**開始 (Start)**してから操作します。

3. **スナップショットの取得** – 操作後にもう一度ヒープスナップショットを取得します。同じページで以前の操作前と操作後でスナップショットが 2 つできた状態になります。Allocation Timeline を記録していた場合は**停止 (Stop)**して結果を確認します。

4. **結果の比較・分析** – 2 つのスナップショットを**Compare**モードで比較し、増加したオブジェクトやメモリ量を確認します。特定のクラスやタイプのオブジェクト数が操作後に増えて減っていない場合、それがリークしている可能性があります。対象のオブジェクトを選択し、**Retainers（保持経路）**ツリーを調べることで、どのオブジェクトや変数がそれを参照し続けているかを突き止めます。例えば「detached DIV element」が多数残っていれば、それらを保持しているイベントリスナーや配列などを探します。

5. **原因箇所の修正** – 保持経路の分析から、自分のコード上で該当オブジェクトを解放していない箇所（イベントリスナーの削除漏れ、グローバル配列に追加したままなど）を特定し、コードを修正します。再度同じ手順でメモリプロファイルを取り、リークが解消したこと（不要オブジェクトが増えなくなったこと）を確認します。

Chrome DevTools のメモリ分析機能は強力ですが、記録中はアプリが一時停止したり動作が重くなることがあるため、本番環境ではなく開発環境で実行するようにします。また、**Performance**パネルでもタイムライン上に「JS Heap」の使用量グラフが表示されるため、メモリ使用量の傾向をざっくり把握するのに役立ちます ([フロントエンドのパフォーマンス改善とメモリリーク対策の方法](https://www.techscore.com/blog/2017/12/24/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA/#:~:text=%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E5%AF%BE%E7%AD%96%E3%81%AE%E6%96%B9%E6%B3%95%20%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%82%92%E6%A4%9C%E7%9F%A5%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%81%AF%E3%80%81%E5%85%88%E3%81%BB%E3%81%A9%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%A7%E3%82%82%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E3%80%81%20Chrome%20DevToos%20%E3%81%AE,Performance%20%E3%83%91%E3%83%8D%E3%83%AB%E3%82%92%E4%BD%BF%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20%E3%81%9D%E3%81%AE))。メモリリークの疑いがある場合、Performance 記録で時間経過に沿ってヒープサイズが右肩上がりで増え続けガベージコレクション後も元に戻らない、といったパターンが見られることがあります。

### Edge のメモリ診断ツール

**Microsoft Edge (Chromium 版)**の開発者ツールも基本的には Chrome と同等の機能を備えています。Edge の DevTools は Chromium ベースであり、メモリパネルでのヒープスナップショット取得や割り当てタイムライン解析などの操作手順・UI は Chrome の場合と同じです。したがって、Chrome で習得したメモリプロファイリング手法は Edge でもそのまま活用できます。Edge 固有の機能としては、非アクティブタブのメモリ節約状況を可視化するグラフ表示（Edge 100 からの機能）や、Edge タスクマネージャでスリープ中のタブを一覧できる点などがあります ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。しかし、純粋なメモリリーク調査に関しては Chromium DevTools の機能に依存しているため、Chrome と同様にヒープスナップショット比較や Retainers 分析を行うことになります。

Edge (Chromium) 以外に、旧 Edge (EdgeHTML エンジン) や他のブラウザを調査する場合は各ブラウザ固有の開発者ツールを使用する必要があります。旧 Edge にもメモリ分析ツールがありましたが、現在主流の Chromium 版 Edge では前述の通り Chrome と同じ手法で対応可能です。なお Firefox などでは独自のメモリ分析ツールを提供していますが、基本的なアプローチ（不要オブジェクトの検出、保持元の特定）は同様です。

**メモリリークの発見とデバッグ**には地道な分析が必要ですが、開発者ツールを駆使することで原因究明の効率が格段に上がります。リアルタイムのメモリグラフやスナップショット比較結果を観察し、コード上のどの部分がメモリ解放を妨げているか突き止めていきます。ブラウザのツールだけで難しい場合、Heap Analytics 用のサードパーティツールや、極端な場合にはブラウザのメモリダンプを取得して解析する方法もありますが、まずは Chrome/Edge の標準ツールで十分なケースが大半です。

## コンポーネント単体の状態管理 vs グローバル状態管理

**コンポーネント単体（ローカル）**の状態管理と**グローバル**な状態管理にはそれぞれ利点とトレードオフがあり、メモリや CPU 負荷の観点からも違いが現れます。

### ローカルステートとグローバルステートの違い

ローカルステートとは、各コンポーネント内部やその直近のサービスで管理される状態を指します。コンポーネントが破棄されると同時にその状態も破棄されるため、**ライフタイムがコンポーネント（ビュー）単位**で完結します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Local%20state))。一方、グローバルステートはアプリ全体で共有される状態で、一般的にアプリ起動から終了まで**アプリケーションのライフタイム全体**で保持されます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Global%20state))。NgRx ストアは典型的なグローバルステートであり、アプリが動作している間は基本的にストア内のデータは生き続けます。

この違いから、**メモリ負荷**について言えばローカルステートの方が不要になったデータを速やかに解放しやすいです。例えばあるコンポーネント内だけで使うオブジェクトをローカルステートで管理すれば、コンポーネント破棄とともにそのオブジェクトへの参照も無くなり、GC によりメモリから除去されます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Local%20state))。逆にそれをグローバルステートに入れていた場合、コンポーネントを破棄してもストア上にデータが残り続け、意図的に削除しない限りメモリを占有し続けます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。短命なデータはローカルに持つ方がメモリ効率的と言えます。

**CPU 負荷（パフォーマンス）**の面では、一概にどちらが有利とは言えませんがケースによります。ローカルステートはそのコンポーネントと子孫コンポーネントにだけ影響を与えるため、状態変更に伴う UI 再描画のコストが局所的ですみます。他の独立した画面には波及しないので、アプリ全体への影響を抑えられます。一方、グローバルステートの場合、状態変更が発生すると全ての購読中のコンポーネントに通知が飛びます。適切に**セレクタ**や`OnPush`を使っていれば実際に再レンダリングされるのは影響範囲のコンポーネントだけですが、それでもアプリ全体で単一のストアが変化するため、**大規模アプリでは一度の変更で多数の箇所が反応する可能性**があります。例えば大きなストアオブジェクトが丸ごと新しくなった場合、OnPush でないコンポーネントはすべて変更検知が走ってしまうかもしれません。こうした無駄を避けるにはストアを細かくスライスしてセレクタで最小限の部分だけ購読する工夫が必要です。

もう一つ CPU 面で言えば、**重い計算処理を伴う状態更新**の場合です。ある計算結果を算出して状態にセットする処理を複数コンポーネントでそれぞれ行うより、グローバルに一度計算して結果を共有した方が無駄な重複計算が減り CPU 負荷を下げられる場合があります。このように、グローバルステートは計算やデータ取得の一元化による効率化につながるケースもあります。一方、不要な頻度でグローバルな変更通知を出してしまうと逆効果になるため、**グローバルとローカルの使い分け**が大切です。

### アプリの規模による最適な選択肢

小規模なアプリケーションでは、必ずしもグローバル状態管理は必要ありません。コンポーネントごとにサービスや内部 state で状態を持ち回りして十分にシンプルに実装できる場合、NgRx のような大がかりな仕組みを導入するとかえってコード量や理解コストが増えます。ローカルステート中心であれば、使い終わったデータは画面破棄とともに自動でメモリから消えるためリークの心配も少なく、パフォーマンスチューニングも局所的に行いやすいでしょう。

一方、アプリが中〜大規模になり**複数のコンポーネント間で状態を共有する必要**が増えてくると、グローバルステート管理のメリットが大きくなります。例えばユーザーの認証情報やカートの内容など、アプリ全域で参照されるデータは一箇所（グローバルストア）で管理した方が一貫性が保ちやすく、各所へのデータ渡しもシンプルになります ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。グローバルストアを導入すると**「単一情報源 (Single Source of Truth)」**として状態を集中管理でき、バグの原因となる状態の不整合を減らせる利点があります ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL))。ただしその場合でも、**全てをグローバルに詰め込まない**ことが肝要です。先述のように局所的な状態は各コンポーネント内に留め、**本当にアプリ全体で必要なものだけ**をグローバルストアに置く設計にすると、メモリとパフォーマンスのバランスが良くなります。NgRx では最近**ComponentStore**という各コンポーネント専用の小さなステート管理機能も提供されており、グローバル Store と組み合わせて使うことで必要最小限のグローバル状態に留めることもできます。

以上を整理すると、**ローカル vs グローバル状態管理の選択**は以下の基準によると良いでしょう。

- **状態のスコープ**: 「このデータはアプリ全体で共有すべきか？特定の画面内だけで完結するか？」を判断します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,other%20views%20for%20example))。後者であればローカル管理で十分です。前者ならグローバルストアに置く価値があります。

- **ライフサイクル**: 「この状態はアプリ起動中ずっと必要か？一時的か？」を考えます。常に必要なもの（例:ログインユーザ情報）はグローバル、短期間で不要になるもの（例:一時的なフィルタ条件）はローカルが適しています ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。

- **共有の必要性**: 複数のコンポーネントやモジュールにまたがって参照・更新されるならグローバルに、単一 UI 内で閉じていればローカルに保持します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,other%20views%20for%20example))。

- **性能面のコスト**: 計算コストの高い処理結果を色々な箇所で使うなら一度グローバルで計算共有した方が効率的です。逆に頻繁に変わる UI 状態（ユーザ操作で ON/OFF する UI 要素の状態など）をいちいちグローバルに上げると、無駄な通知が増えて重くなる可能性があります。

適切に判断すれば、ローカルとグローバル状態管理を組み合わせることでメモリと CPU の使用効率を最適化できます。例えば**「グローバル：ユーザや設定など長期間共有される状態」「ローカル：画面固有の一時的な状態」**と分離することで、必要十分なデータだけがメモリに残り続け、不要なものは破棄されるバランスの取れたアプリ設計となります。その上で NgRx のような仕組みを使えば大規模でも整然と状態管理できますし、逆に小規模なら無理に導入せずシンプルに保つ方が結果として軽量に動作するでしょう。

## ブラウザのメモリ許容量と PC スペック依存の関係

### ブラウザのメモリ最大使用量

Chrome や Edge などモダンブラウザは、64bit 環境では理論上非常に大量のメモリを扱えますが、**内部的にタブ（レンダラープロセス）毎のメモリ使用に上限**を設けています。Chrome では一つのレンダラープロセス（タブ）が使用できるメモリはおよそ**16GB**程度に制限されており、Edge も同様です ([Error code: Out of Memory - How to allocate more memory to Google Chrome - 64 GB ram available - Super User](https://superuser.com/questions/1675677/error-code-out-of-memory-how-to-allocate-more-memory-to-google-chrome-64-gb#:~:text=1,you%20hit%20the%2016G%20limit))。これは OS やブラウザ自体のアーキテクチャ上の制約によるもので、仮に PC に 2TB もの膨大な RAM を積んでいても、1 つのタブが 16GB 以上メモリを消費しようとすると**"Out of Memory"**エラーが発生してページがクラッシュします ([Error code: Out of Memory - How to allocate more memory to Google Chrome - 64 GB ram available - Super User](https://superuser.com/questions/1675677/error-code-out-of-memory-how-to-allocate-more-memory-to-google-chrome-64-gb#:~:text=1,you%20hit%20the%2016G%20limit))。この上限は以前は 4GB 前後（特に 32bit 版ではアドレス空間の制限で約 4GB）でしたが、近年の 64bit 版では拡張されました。ただし**16GB ものメモリを単一タブで使い切るケースは非常に稀**であり、通常はその前にユーザが不便を感じたり、PC 全体のメモリが不足したりするでしょう。

ブラウザ全体で見れば、開けるタブ数や利用可能なメモリ容量には実質上**PC の物理 RAM 容量**が上限となります。例えば 8GB RAM の環境では OS 自体やバックグラウンドプロセスが数 GB 使用するため、ブラウザに使えるメモリはせいぜい 4 ～ 5GB 程度です ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。一方 16GB 搭載なら 10GB 以上、32GB なら 20 数 GB と、搭載 RAM が多いほどブラウザが快適に使えるメモリも増加します ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。実際の計測では、Windows10 でメモリ 8GB の PC では「利用可能」メモリがおよそ 4.5GB だったのに対し、16GB では 12.3GB、32GB では 28GB がそれぞれ空きとして確保できていました ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。つまり OS が占有する分を除けば、**残りは基本的にブラウザなどアプリが自由に使える**ので、RAM を増設すればその分だけ多くのタブを開いたり重いページを読み込んだりできる計算になります。

ただし物理メモリを超えてさらにブラウザがメモリを要求し続けると、OS はスワップ（ディスク上の仮想メモリ）を使い始めます。スワップは非常に遅いため、ディスクアクセスが発生し始めるとブラウザの動作は極端に重くなります。Chrome ではメモリ不足時にタブを自動的に破棄して再読み込みを促す措置（前述のタブ破棄）が取られることもありますが、ユーザが大量のタブを開きっぱなしにしていると OS 側で強制的にプロセスが落とされる（OOM Killer による終了）可能性もあります。いずれにせよ、**ブラウザの実質的な使用可能メモリ容量=PC の搭載 RAM - OS その他が使う分**と考えてよいでしょう。

### CPU スペックによる処理能力の変動

CPU の性能やコア数も、ブラウザのパフォーマンスに大きな影響を与えますが、**メモリ許容量そのものには直接的な変化を与えません**。例えば同じ 16GB RAM でも、低速な CPU では多数のタブを開いたときに処理が追いつかずカクついたり、GC に時間がかかってメモリ解放が遅れる可能性があります。一方、高性能な CPU（高速クロック・多コア）であれば、各タブの処理を並行してこなせるため、より多くのタブを快適に扱えるでしょう。Chrome や Edge はマルチプロセスなので、**コア数の多い CPU ほど複数タブを同時に動かすのに有利**です。例えば 8 コア CPU なら重いタブ 8 個まである程度スムーズに動作しますが、2 コア CPU だと 2 つ開いた時点で CPU リソースが飽和しやすくなります。

また CPU 性能が高いと**ガベージコレクションの実行も迅速**になるため、結果的にメモリリークに強くメモリ使用量を低めに抑えられる場合もあります。例えば同じ Web アプリを動作させても、遅い CPU では GC が追いつかず一時メモリ使用量が増える場面で、高速 CPU なら素早く不要メモリを回収できるかもしれません。ただし根本的なメモリの最大許容量は変わらないため、CPU さえ良ければ無制限にメモリを使えるわけではありません。

総合すると、**ブラウザのメモリ使用上限は主にソフトウェア制限(タブあたり約 16GB)と搭載 RAM 量に依存**し、CPU 性能は主として**処理速度や同時実行性**の面で寄与します。高性能な PC ほど多数のタブをスムーズに扱え、大容量 RAM ほど多くのデータをメモリ上に保持できます。逆に低スペックな PC では少数のタブでもメモリ逼迫や CPU 過負荷に陥りやすいため、Chrome では不要タブの自動破棄や Edge のスリープタブといった省資源機能が特に効果を発揮します ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Despite%20Sleeping%20Tabs%20being%20built,based%20on%20system%20RAM%20levels))。開発者・ユーザ双方の視点で言えば、**自分の PC スペックに見合ったタブ数や Web アプリの設計**を心掛け、限られたリソースを有効活用することが大切です。

---

本調査により、メモリ管理の原理からブラウザ固有の挙動、NgRx 状態管理の工夫まで幅広く把握できました。適切なメモリ管理戦略を取ることで、不要なメモリ消費やリークを防ぎつつ、快適で効率的な Web アプリケーションを構築できるでしょう。NgRx を用いたグローバル状態管理では、必要なデータを適切に管理し、開発者ツールでメモリ挙動を監視することで、安全かつスケーラブルな状態管理が可能です。また Chrome や Edge といったブラウザのメモリ特性を理解することで、ユーザの利用環境に配慮したアプリの動作や、不具合発生時の的確なデバッグにつなげられるはずです。今後はこれら知見を踏まえて、より効率的な NgRx の活用とブラウザメモリ管理の最適化に取り組んでいきます。 ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82)) ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))
