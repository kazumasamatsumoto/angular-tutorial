了解しました！

以下の内容について詳しく調査し、お伝えします。

- 一般的なメモリの動作原理（ガベージコレクション、ヒープ/スタックメモリ）
- Chrome と Edge のメモリ管理の違い
- NgRx とメモリ消費の関係（メモリリーク対策、最適化）
- 開発者ツールを使ったメモリの監視方法
- コンポーネント単体の状態管理とグローバルな状態管理のメモリや CPU の処理の違い
- ブラウザのメモリの許容量と PC スペック依存の場合の計算式

調査が完了次第、詳細をお伝えします！

# NgRx のメモリ消費とブラウザのメモリ管理に関する調査レポート

## 一般的なメモリの動作原理

### ガベージコレクションの仕組み

JavaScript などの高水準言語では、オブジェクト生成時に必要なメモリを自動で確保し、不要になれば自動で解放する「ガベージコレクション (GC)」によるメモリ管理が行われます ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。GC の代表的なアルゴリズムである**マークアンドスイープ (mark-and-sweep)**法では、「到達不能(どの変数からも参照されなくなった)オブジェクト」を**不要なオブジェクト**とみなし、メモリから回収します ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0))。現在の全ての主要な JavaScript エンジンはマークアンドスイープ方式の GC を搭載しており、**世代別 GC**・**インクリメンタル GC**・**並行 GC**などの手法で効率や停止時間の改善が図られています ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82))。世代別 GC では生成後間もなく消えるオブジェクトと長寿命のオブジェクトを分けて管理し、若い世代を高頻度で収集することで効率化します。このように自動 GC により開発者が明示的にメモリ解放する必要はありませんが、**「参照」が残っている限り GC は解放できない**ため、コードの不備でオブジェクトへの参照が残り続けるとメモリリークが発生します ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82)) ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。例えばグローバル変数に不要なオブジェクトを保持したままにしたり、イベントリスナーの登録解除漏れで DOM 要素への参照が残るケースなどでは、GC が対象と判断できずメモリ上にオブジェクトが残り続けてしまいます。

### ヒープメモリとスタックメモリの違い

プログラムが使用するメモリ領域には大きく分けて**スタック**と**ヒープ**があります。**スタック**は関数呼び出しやローカル変数など一時的なデータ用の領域で、固定長のデータを後入れ先出し（LIFO）で管理します。例えば JavaScript エンジンは、コンパイル時点でサイズが確定するプリミティブ値（数値・文字列・真偽値など）やオブジェクトへの参照をスタック領域に割り当てます ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%8C%E6%B1%BA%E3%81%BE%E3%82%8B%E5%80%A4%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%81%AF%E3%80%81%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A1%8C%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%9D%99%E7%9A%84%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%A8%E3%82%82%E8%A8%80%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%20%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E3%81%AB%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%8C%E6%B1%BA%E3%81%BE%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%81%A8%E3%81%97%E3%81%A6%E3%80%81%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B,Last%20In%20First%20Out))。スタック領域は高速にアクセスできますが各データのサイズが固定であり、関数の終了とともに自動的に解放されます。一方、**ヒープ**は動的にサイズが決まるオブジェクトを格納するための大きな領域で、構造が柔軟な分アクセスはスタックより遅くなります ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%AF%E3%80%81%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%A8%E7%95%B0%E3%81%AA%E3%82%8A%E3%80%81%E6%A7%8B%E9%80%A0%E5%8C%96%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82))。JavaScript では**オブジェクトや配列、関数の実体はヒープ領域に確保され、その参照（ポインタ）だけがスタックに置かれる**という形をとります ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E3%81%82%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AF%E5%A4%89%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%80%81JavaScript%20%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%81%AF%E5%90%84%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E5%9B%BA%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82%E4%B8%80%E6%96%B9%E3%80%81%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%20%E3%81%AB%E3%81%82%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AF%E5%8F%AF%E5%A4%89%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81%E5%9B%BA%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E3%81%9B%E3%81%9A%E3%80%81%E5%BF%85%E8%A6%81%E3%81%AB%E5%BF%9C%E3%81%98%E3%81%9F%E5%A4%9A%E3%82%81%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E9%A0%98%E5%9F%9F%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82)) ([JavaScript がブラウザでどのように動くのか | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220128-3a0922eaa4/#:~:text=match%20at%20L210%20%E9%96%A2%E6%95%B0%E3%82%84%E9%85%8D%E5%88%97%E3%82%82%E5%90%8C%E6%A7%98%E3%81%AB%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A7%E3%80%81%E5%AE%9F%E4%BD%93%E3%81%8C%E3%83%92%E3%83%BC%E3%83%97%E9%A0%98%E5%9F%9F%E3%81%AB%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%80%81%E5%AE%9F%E6%85%8B%E3%81%AE%E5%8F%82%E7%85%A7%E3%81%8C%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%20%E4%B8%80%E6%96%B9%E3%80%81%E6%96%87%E5%AD%97%E5%88%97%E3%82%84%E6%95%B0%E5%80%A4%E7%AD%89%E3%81%AE%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B%E3%82%92%E5%AE%A3%E8%A8%80%E3%81%97%E3%81%9F%E6%99%82%E3%80%81JavaScript,%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%81%AF%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%A0%98%E5%9F%9F%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A1%8C%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。例えばオブジェクトを生成すると、その内容はヒープ上に配置され、スタック上の変数にはヒープ上のオブジェクトへの参照が格納されます。このようにスタックとヒープで役割が異なり、スタックは固定サイズで高速・自動解放、ヒープは可変サイズで GC による管理といった特徴があります。

### JavaScript におけるメモリ管理の特徴

JavaScript は上述のとおり**自動メモリ管理**の言語であり、低レベル言語のように開発者が`malloc`や`free`を直接呼び出す必要がありません ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E4%B8%80%E9%83%A8%E3%81%AE%E9%AB%98%E6%B0%B4%E6%BA%96%E8%A8%80%E8%AA%9E%E3%80%81%E4%BE%8B%E3%81%88%E3%81%B0%20JavaScript%20%E3%81%AF%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%20,%E3%81%AE%E6%96%B9%E5%BC%8F%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AF%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E7%9B%A3%E8%A6%96%E3%81%97%E3%80%81%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E5%88%A4%E6%96%AD%E3%81%97%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%9B%9E%E5%8F%8E%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%20%E3%81%A7%E3%81%99%E3%80%82%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%81%8C%E3%81%BE%E3%81%A0%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E6%96%AD%E3%81%99%E3%82%8B%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AF%E6%B1%BA%E5%AE%9A%E4%B8%8D%E8%83%BD%E3%81%A7%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E5%87%A6%E7%90%86%E3%81%AF%E8%BF%91%E4%BC%BC%E7%9A%84%E3%81%AA%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%80%82))。これはメモリリークのリスクを減らす利点がありますが、「自動だからメモリ管理を気にしなくてよい」というわけではありません ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AB%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%82%92%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%AB%E7%A2%BA%E4%BF%9D%E3%81%97%E3%80%81%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%82%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%BC%E3%82%92%E8%A7%A3%E6%94%BE%E3%81%97%E3%81%BE%E3%81%99%EF%BC%88%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%80%82%E3%81%93%E3%81%AE%E8%87%AA%E5%8B%95%E6%80%A7%E3%81%8C%E6%B7%B7%E4%B9%B1%E3%81%AE%E5%85%83%E3%81%AB%E3%81%AA%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%83%A1%E3%83%A2%20%E3%83%AA%E3%83%BC%E7%AE%A1%E7%90%86%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E5%BF%83%E9%85%8D%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%AA%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E8%AA%A4%E3%81%A3%E3%81%9F%E5%8D%B0%E8%B1%A1%E3%82%92%E9%96%8B%E7%99%BA%E8%80%85%E3%81%AB%E4%B8%8E%E3%81%88%E3%82%8B%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。実際には**プログラム上から参照が消えない限りメモリは解放されない**ため、意図的に不要になったオブジェクトへの参照を断つ工夫が必要です。例えば、不要になったイベントリスナーやタイマーは明示的に解除し、閉じた画面のデータをグローバルストアに保持し続けないようにするなど、**開発者側で「オブジェクトへの参照を適切にスコープから除去する」ことがメモリリーク対策になります**。JavaScript にも`WeakMap`や`WeakRef`といった弱い参照を扱う仕組みがあり、これらは対象が他から参照されなくなれば自動的に破棄される性質を持つため、メモリリークを防ぐ用途で活用できます。総じて、JavaScript のメモリ管理は自動 GC により簡便ですが、根本的なメモリリークの原因（不要な参照が残ること）を防ぐよう設計・コーディングすることが重要です。

## Chrome と Edge のメモリ管理の違い

([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/)) _図: Chrome/Edge のマルチプロセスアーキテクチャ概念図。ブラウザの UI を管理する**ブラウザプロセス**、描画用の**GPU プロセス**、各タブの内容を処理する**レンダラープロセス**、拡張機能用プロセス、プラグイン用プロセスなどに分離されている。プロセス分離により、あるタブがクラッシュしても他のタブやブラウザ本体に影響しないようになっている。_

Chrome は当初より**マルチプロセス構造**を採用しており、各タブ（レンダラ）やプラグインをブラウザ本体とは別のプロセスで動作させます。これにより、あるタブのレンダリングエンジンがクラッシュしてもブラウザ全体や他のタブが巻き添えで落ちることはなく、動作の安定性と応答性が向上します ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。またプロセスが分離されていることでセキュリティ面でも効果があり、レンダラプロセスをサンドボックス化して悪意あるコードの影響をブラウザ全体に及ばないようにしています ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。Chrome は内部にタスクマネージャを備えており、各タブや拡張機能ごとのメモリ消費量や CPU 使用率を確認したり、応答しないプロセスを個別に終了させることができます ([
Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Interestingly%2C%20using%20multiple%20processes%20means,to%20restart%20the%20entire%20browser))。これはプロセスごとにリソースを隔離しているマルチプロセス構造の利点の一つです。

現在の**Microsoft Edge (Chromium 版)**も基本的に Chrome と同じ Blink レンダリングエンジン/V8 実行環境を使用しており、アーキテクチャもマルチプロセス構造です。Edge では各タブを別々のレンダラープロセスとして分離するだけでなく、ページ内に埋め込まれた広告などの**サブフレーム**についても別プロセスに分離する仕組みを持っています ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。例えば Edge では、4 つのタブを開きそれぞれに広告フレームが含まれる場合、タブ本体用のレンダラープロセス 4 つに加え、広告フレーム用のレンダラープロセスがドメインごとに 2 つ立ち上がり、合計 6 つのレンダラープロセスが動作すると報告されています ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。もっとも Chrome もサイトアイソレーションの強化により、異なるドメインの iframe を別プロセスにする動作が導入されており、プロセス分割の方針は両者で似通ってきています。いずれにせよ、Chrome/Edge ともにタブ単位でプロセスを独立させることで**タブごとのリソース管理**を行っており、不要になったタブを閉じればそのプロセスごと OS に回収させることでメモリを解放できます。この設計により、仮に特定のタブで JavaScript のメモリリークが起きても、そのタブを閉じればメモリは完全に解放され、他のタブに影響を残さないという利点があります。

メモリリークやメモリ過剰使用への対策として、**Edge**には「**スリープタブ** (Sleeping Tabs)」という独自機能があります。一定時間操作されていない非アクティブなタブを自動的に休眠状態にし、メモリや CPU リソースの消費を大幅に削減する仕組みです ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Sleeping%20Tabs%20is%20not%20a,you%20left%20off%20without%20delay))。Microsoft によれば、このスリープタブ機能によって「平均で 85%のメモリと 99%の CPU 資源を節約できる」と報告されています ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。スリープ状態になったタブは内部的にページのスクリプト実行が停止され、一部メモリが解放されますが、タブ自体は維持されているため再びアクティブにした際の復元が高速です ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))。Edge ではユーザーが設定でスリープまでの待機時間を変更したり、特定のサイトをスリープ除外リストに登録するといった細かな制御も可能です ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Microsoft%20has%20been%20building%20out,which%20is%20critical%20for%20laptops)) ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=1,System%20and%20performance))。一方、**Chrome**にもメモリ不足時にバックグラウンドタブを一時的にメモリから外す「タブの破棄 (Tab Discarding)」機能が以前から存在し、最近では Chrome 108 以降で Edge に類似した「メモリセーバー」機能も正式に導入されました。この機能では一定時間非使用のタブを自動休止させ、アクティブ時に再読み込みして復元することでメモリ使用量を抑えています。Chrome の従来のタブ破棄はシステムメモリが逼迫した際に OS に通知して未使用タブを完全にメモリから開放する仕組みでした ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))（復帰時には再度ネットワークからページを読み込む必要がある）。新しいメモリセーバーではユーザーが任意に機能をオン/オフできる点など Edge のスリープタブに近い動作になっています ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Despite%20Sleeping%20Tabs%20being%20built,based%20on%20system%20RAM%20levels))。このように**非アクティブタブのリソース開放**に関しては、Edge が先行していた分野に Chrome も追随しつつあり、両ブラウザのメモリ最適化機能は近年収束しつつあります。

以上を踏まえ、Chrome と Edge (Chromium) のメモリ管理の相違点をまとめると次の表のようになります。

| **項目**                  | **Google Chrome**                                                           | **Microsoft Edge** |
| ------------------------- | --------------------------------------------------------------------------- | ------------------ |
| **エンジン/プロセス構造** | Chromium エンジン (Blink/V8)。初期からマルチプロセスアーキテクチャを採用 ([ |

Chromium Blog: Multi-process Architecture
](https://blog.chromium.org/2008/09/multi-process-architecture.html#:~:text=Google%20Chrome%20takes%20advantage%20of,if%20an%20exploit%20does%20occur))。<br>ブラウザ、GPU、各タブ（レンダラ）、プラグイン、拡張機能ごとに独立プロセス。 | Chromium エンジン (Blink/V8)。Chromium 版(現在)は Chrome 同等のマルチプロセス構造 ([Microsoft Edge’s multi-process architecture - Microsoft Edge Blog](https://blogs.windows.com/msedgedev/2020/09/30/microsoft-edge-multi-process-architecture/#:~:text=,in%20the%20web%20page%20using))。<br>タブに加え広告フレームなどサブコンポーネントも別プロセス化。 |
| **メモリ使用傾向** | 多数のプロセスを生成するためメモリ消費は大きいが、高速化の最適化も継続。 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))のテストでは 6 ページ同時表示で**約 1.4GB**使用。 | 同じ Chromium ベースでも独自最適化でメモリ効率が良いとの報告あり。 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))の同条件テストでは**約 665MB**と Chrome の半分以下だった。 |
| **非アクティブタブの扱い** | 従来はメモリ逼迫時に非表示タブを**破棄**しメモリ解放（再表示時に再読み込み） ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless))。<br>2022 年以降は**メモリセーバー**機能により一定時間非使用タブを休止状態にしてリソース節約（ユーザー設定可能）。 | **スリープタブ**機能により一定時間非操作のタブを自動休眠し、平均でメモリ 85%削減 ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。復帰も即座に可能。<br>また「効率モード」でバッテリー残量低下時等にタブ休眠を積極化する機能も搭載。 |
| **メモリリーク対策** | タブ毎のプロセス隔離により、一つのタブ内でリークが起きても他に影響せず、タブを閉じれば OS が全メモリ回収。<br>DevTools のメモリプロファイラでリーク検出・解消が可能（後述）。 | Chrome 同様のプロセス隔離による局所化。タブ休眠機能で長時間開きっぱなしのタブによるメモリ浪費を防止。<br>開発者ツールも Chromium ベースで同等のメモリ分析機能を提供。 |
| **開発者向けツール** | Chrome DevTools に「Memory」パネルがありヒープスナップショットや割り当てタイムラインでメモリを詳細分析可能。 ([Memory panel overview  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory#:~:text=The%20Memory%20panel%20provides%20diagnostic,allocation%20by%20function%2C%20and%20more)) | Edge も DevTools は Chrome と同一基盤のため「メモリ」タブで同様のプロファイルが可能。<br>Edge 独自機能としてタスクマネージャやスリープタブの効果を可視化するグラフ表示などがある。 |

_表: Chrome と Edge (Chromium 版) におけるメモリ管理の比較 ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023)) ([Learn about performance features in Microsoft Edge - Microsoft Support](https://support.microsoft.com/en-us/topic/learn-about-performance-features-in-microsoft-edge-7b36f363-2119-448a-8de6-375cfd88ab25#:~:text=A%20sleeping%C2%A0tab%20simply%20pauses%20the,again%20is%20fast%20and%20seamless)) ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))_

## NgRx とメモリ消費の関係

### グローバル状態管理によるメモリ使用量

NgRx は Redux パターンに基づく**グローバル状態管理**ライブラリであり、アプリ全体の状態を単一の大きな JavaScript オブジェクト（**ストア**）で管理します。ストアに保持された状態はメモリ上に常駐するため、その内容が増大すればアプリのメモリ使用量も増加します。必要以上に大量のデータをストアに保持し続けることは**「過剰な状態保持」**となり、メモリフットプリント肥大化の原因となります。例えば本来一画面でしか使わない一時的なデータまでもグローバルストアに保存し続けると、ユーザーが画面遷移して使わなくなった後もメモリを圧迫し続けることになります。また NgRx ストアは基本的にアプリ実行中は保持され続けるため、アプリの稼働時間が長くなるシナリオ（SPA を長時間リロードせず使う等）では、使い終わったデータを明示的に削除しない限りメモリ使用量が蓄積する傾向があります。このため、必要なデータだけを適切な**スライス（部分領域）**に分割して管理し、不要になったらストアから削除する工夫が重要です。

また NgRx では状態変更のたびに**Immutable（不変）な新オブジェクト**を生成するため、古いオブジェクトへの参照がどこにもなくなれば GC で回収されます。しかし、Redux DevTools 拡張などで状態の履歴を大量に保持していると開発時にメモリを多く消費する場合があります（本番ビルドでは通常履歴保持しないので問題ありません）。いずれにせよ、NgRx 自体はメモリリークを起こさないよう設計されていますが、その**使い方次第でメモリ消費が大きく変わる**点に注意が必要です。

### メモリリークの原因（購読の解除忘れ等）

NgRx によるメモリリークでもっとも多い原因は、**ストアからの状態購読(Subscription)管理ミス**です。コンポーネントで`this.store.select(...).subscribe(...)`のようにストアの Observable を購読した場合、コンポーネントが破棄されても購読を解除(`unsubscribe`)しない限り、ストアから値が流れ続けます。解除漏れがあると、不要になったコンポーネントやその変数がストアの Observable 経由で参照され続け、GC で回収されずにメモリに残ってしまいます。これが**メモリリーク**につながります ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。対策として、Angular コンポーネントの`OnDestroy`で確実に`unsubscribe`するか、`takeUntil`演算子や`AsyncPipe`を用いて自動的に購読解除する仕組みにすることが重要です ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。例えば、`AsyncPipe`を使えばテンプレート上でストアの Observable を直接バインドでき、コンポーネント破棄時に Angular が自動で購読解除してくれます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=data%24%20%3D%20this.store.select%28yourSelector%29.pipe%28%20%2F,))。

もう一つのリーク要因は**不要な状態をストアに残し続けること**です。特に配列やオブジェクトの大量データをストアに保持している場合、画面遷移で使わなくなったら明示的にそれらをクリアするアクションを dispatch するのが望ましいです。NgRx 自体は単一のストアオブジェクトを常に参照し続けるため、ストアからデータを削除しない限りメモリ上に居座ります。例えば大量の一覧データを取得してストアに保存したままにすると、ユーザーが別機能に移動してその一覧を見ていなくてもメモリを消費し続けます。**メモリリーク**という厳密な意味では「不要な参照が残り続けること」ですが、NgRx では**使わないデータを解放し忘れる論理的リーク**にも注意が必要です。

### NgRx のメモリ最適化手法

NgRx を効率的に利用するためには、以下のようなメモリ最適化の手法が有効です。

- **ストアのスライス設計と Lazy Loading**: アプリ状態を機能ごとのスライス（区画）に分割し、必要なときにだけロードするようにします。Angular の Lazy Load 機能と NgRx を組み合わせ、遷移時に対応するリデューサーと状態を動的に追加することで、使っていない機能の状態をメモリに載せない工夫ができます。例えば、大規模アプリでユーザー設定機能のモジュールを Lazy Load にしておけば、ユーザー設定画面を開くまでその状態スライスはストアに存在せずメモリを節約できます。将来的に NgRx ではストアから状態スライスを削除する仕組み（動的に reducer を外す）が提供されつつあり、不要領域のメモリを開放できる可能性もあります。

- **コンポーネント単位の状態管理の活用**: 全てをグローバルストアで管理せず、コンポーネント内部の`ComponentStore`（NgRx ComponentStore モジュール）や単純なサービス＋ BehaviorSubject で局所的に状態管理するのも有効です。局所状態であればコンポーネント破棄時に自動的にメモリが開放され、グローバルに残るデータを減らせます。特に UI の一時的な表示状態（開閉フラグなど）やフォーム入力値などはグローバルに持たずローカル状態で十分です。

- **変更検知戦略 OnPush の利用**: Angular コンポーネントを`ChangeDetectionStrategy.OnPush`に設定することで、不必要な再レンダリングを減らしパフォーマンスを向上できます。直接的なメモリ削減策ではありませんが、OnPush により不要な差分計算やコンポーネント生成が抑制されるため、結果的にガベージコレクタの負担軽減や一時オブジェクトの削減につながります。また OnPush と NgRx は相性が良く、ストアからの状態変更通知を`AsyncPipe`で受け取る場合は自動的に OnPush でも変化検知されるため、効率的な UI 更新が可能です。

- **RxJS 演算子による購読数削減**: NgRx のセレクタを複数箇所で利用する際に、`shareReplay`などを使って Observable を共有化することで無駄な計算やメモリ使用を減らせます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=const%20s%20%3D%20new%20Subject)) ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=If%20you%20subscribe%20to%20,operators))。例えば同じ`select`結果を複数回`subscribe`するとその分オブジェクトが生成されますが、`share()`を挟めば一度の計算結果を使い回せます ([Angular memory optimization with NgRx store to avoid memory leaks - Stack Overflow](https://stackoverflow.com/questions/66075764/angular-memory-optimization-with-ngrx-store-to-avoid-memory-leaks#:~:text=If%20you%20subscribe%20to%20,operators))。これにより不要なオブジェクトインスタンスの乱立を防ぎ、メモリ効率を上げることができます。

以上のように、NgRx 利用時は**「どの状態をどこまで保持するか」**を適切に設計し、RxJS 購読の寿命管理を徹底することが重要です。適切に実装すれば NgRx 自体が大きなメモリ負荷やリークの原因になることはなく、アプリの状態を一元管理しつつ健全なメモリ使用量を維持できます。

## 開発者ツールを使ったメモリの監視方法

### Chrome DevTools でのメモリプロファイリング

Chrome が提供する**DevTools**には強力なメモリ診断ツールが含まれています。DevTools の「**Memory**」パネルでは、ヒープメモリ内訳のスナップショット取得やメモリ割り当て状況のタイムライン記録などを行え、JavaScript オブジェクトのメモリ分布を分析して**メモリリークの発見と特定**ができます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E5%88%86%E5%B8%83%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%80%81%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%AE%E6%A4%9C%E5%87%BA%E3%81%A8%E5%88%86%E9%9B%A2%E3%80%81%E9%96%A2%E6%95%B0%E3%81%94%E3%81%A8%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%81%AE%E5%86%85%E8%A8%B3%E3%81%AE%E5%8F%96%E5%BE%97%E3%81%AA%E3%81%A9%E3%82%92%E8%A1%8C%E3%81%86%E8%A8%BA%E6%96%AD%E3%83%84%E3%83%BC%E3%83%AB%E3%81%8C%E7%94%A8%E6%84%8F%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。代表的な機能は次のとおりです ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82)):

- **Heap Snapshot (ヒープスナップショット)** – ヒープ内のオブジェクトと DOM ノードのメモリ使用状況を記録し、種類ごとのメモリ占有量を表示します。スナップショット間の**比較**機能もあり、特定の操作前後でオブジェクト数やメモリサイズの増減を比較することでリークしているオブジェクトを絞り込めます ([Record heap snapshots  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots#:~:text=compare%20snapshots%2C%20and%20find%20memory,information%2C%20see%20Objects%20retaining%20tree))。

- **Allocation Timeline (割り当てタイムライン)** – 一定期間のメモリアロケーション（割り当て）イベントを記録し、時間経過に沿ったメモリ使用量の推移を表示します。特定の時間区間を選択すると、その間に確保され、記録終了時点まで生存しているオブジェクトを抽出できます。これにより**どの操作で確保されたオブジェクトが解放されず残っているか**を特定し、メモリリークを隔離するのに役立ちます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82))。

- **Allocation Sampling (割り当てサンプリング)** – メモリ割り当てをサンプリングベースで記録する軽量プロファイルです。長時間動作する処理でもオーバーヘッド低く測定でき、関数ごとのメモリ割り当て状況を大まかに把握できます ([メモリパネルの概要  |  Chrome DevTools  |  Chrome for Developers](https://developer.chrome.com/docs/devtools/memory?hl=ja#:~:text=,%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%3A%20%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%92%E8%A8%98%E9%8C%B2%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%97%E3%81%AE%E3%83%97%E3%83%AD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%80%81%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%81%8C%E6%9C%80%E3%82%82%E4%BD%8E%E3%81%8F%E3%80%81%E9%95%B7%E6%99%82))。

- **Detached Elements (デタッチされた要素)** – メモリ上に残っているが DOM ツリー上は外された（いわゆる「死んだ」）DOM 要素を一覧表示します。イベントリスナーなどどこかで参照されているため GC されていない要素を検出でき、典型的なメモリリーク（削除したはずの DOM がメモリから消えていない）の発見に有用です。

Chrome DevTools を用いた基本的なメモリリーク調査手順は以下のようになります：

1. **ベースラインの取得** – 問題となるページを開いた状態で Memory パネルからヒープスナップショットを 1 回取得します。まず強制 GC（ごみ箱アイコン）を実行して不要メモリを可能な限り回収した上でスナップショットを取り、これをベースラインとします。

2. **操作の実行** – 次に調査したい操作（例：画面遷移を何度も繰り返す、データをロードするなど）を行い、メモリ使用量が増加する状況を作ります。操作中のメモリアロケーションを記録したい場合、Allocation Timeline を**開始 (Start)**してから操作します。

3. **スナップショットの取得** – 操作後にもう一度ヒープスナップショットを取得します。同じページで以前の操作前と操作後でスナップショットが 2 つできた状態になります。Allocation Timeline を記録していた場合は**停止 (Stop)**して結果を確認します。

4. **結果の比較・分析** – 2 つのスナップショットを**Compare**モードで比較し、増加したオブジェクトやメモリ量を確認します。特定のクラスやタイプのオブジェクト数が操作後に増えて減っていない場合、それがリークしている可能性があります。対象のオブジェクトを選択し、**Retainers（保持経路）**ツリーを調べることで、どのオブジェクトや変数がそれを参照し続けているかを突き止めます。例えば「detached DIV element」が多数残っていれば、それらを保持しているイベントリスナーや配列などを探します。

5. **原因箇所の修正** – 保持経路の分析から、自分のコード上で該当オブジェクトを解放していない箇所（イベントリスナーの削除漏れ、グローバル配列に追加したままなど）を特定し、コードを修正します。再度同じ手順でメモリプロファイルを取り、リークが解消したこと（不要オブジェクトが増えなくなったこと）を確認します。

Chrome DevTools のメモリ分析機能は強力ですが、記録中はアプリが一時停止したり動作が重くなることがあるため、本番環境ではなく開発環境で実行するようにします。また、**Performance**パネルでもタイムライン上に「JS Heap」の使用量グラフが表示されるため、メモリ使用量の傾向をざっくり把握するのに役立ちます ([フロントエンドのパフォーマンス改善とメモリリーク対策の方法](https://www.techscore.com/blog/2017/12/24/%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA/#:~:text=%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E5%AF%BE%E7%AD%96%E3%81%AE%E6%96%B9%E6%B3%95%20%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%82%92%E6%A4%9C%E7%9F%A5%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%81%AF%E3%80%81%E5%85%88%E3%81%BB%E3%81%A9%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%A7%E3%82%82%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E3%80%81%20Chrome%20DevToos%20%E3%81%AE,Performance%20%E3%83%91%E3%83%8D%E3%83%AB%E3%82%92%E4%BD%BF%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20%E3%81%9D%E3%81%AE))。メモリリークの疑いがある場合、Performance 記録で時間経過に沿ってヒープサイズが右肩上がりで増え続けガベージコレクション後も元に戻らない、といったパターンが見られることがあります。

### Edge のメモリ診断ツール

**Microsoft Edge (Chromium 版)**の開発者ツールも基本的には Chrome と同等の機能を備えています。Edge の DevTools は Chromium ベースであり、メモリパネルでのヒープスナップショット取得や割り当てタイムライン解析などの操作手順・UI は Chrome の場合と同じです。したがって、Chrome で習得したメモリプロファイリング手法は Edge でもそのまま活用できます。Edge 固有の機能としては、非アクティブタブのメモリ節約状況を可視化するグラフ表示（Edge 100 からの機能）や、Edge タスクマネージャでスリープ中のタブを一覧できる点などがあります ([「Microsoft Edge 100」にリソース節約量を表示するグラフ ～スリープタブ技術の弱点も解消 - 窓の杜](https://forest.watch.impress.co.jp/docs/news/1401375.html#:~:text=Edge%E3%80%8D%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E6%B6%88%E8%B2%BB%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%AE%E5%BF%9C%E7%AD%94%E6%80%A7%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82%E5%90%8C%E7%A4%BE%E3%81%AB%E3%82%88%E3%82%8B%E3%81%A8%E3%80%81%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%85%8B%E3%81%AE%E3%82%BF%E3%83%96%E3%81%AF%E5%B9%B3%E5%9D%87%E3%81%A785%EF%BC%85%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A899%EF%BC%85%E3%81%AECPU%E3%81%8C%E7%AF%80%E7%B4%84%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%AE%20%E3%81%93%E3%81%A8%E3%80%82))。しかし、純粋なメモリリーク調査に関しては Chromium DevTools の機能に依存しているため、Chrome と同様にヒープスナップショット比較や Retainers 分析を行うことになります。

Edge (Chromium) 以外に、旧 Edge (EdgeHTML エンジン) や他のブラウザを調査する場合は各ブラウザ固有の開発者ツールを使用する必要があります。旧 Edge にもメモリ分析ツールがありましたが、現在主流の Chromium 版 Edge では前述の通り Chrome と同じ手法で対応可能です。なお Firefox などでは独自のメモリ分析ツールを提供していますが、基本的なアプローチ（不要オブジェクトの検出、保持元の特定）は同様です。

**メモリリークの発見とデバッグ**には地道な分析が必要ですが、開発者ツールを駆使することで原因究明の効率が格段に上がります。リアルタイムのメモリグラフやスナップショット比較結果を観察し、コード上のどの部分がメモリ解放を妨げているか突き止めていきます。ブラウザのツールだけで難しい場合、Heap Analytics 用のサードパーティツールや、極端な場合にはブラウザのメモリダンプを取得して解析する方法もありますが、まずは Chrome/Edge の標準ツールで十分なケースが大半です。

## コンポーネント単体の状態管理 vs グローバル状態管理

**コンポーネント単体（ローカル）**の状態管理と**グローバル**な状態管理にはそれぞれ利点とトレードオフがあり、メモリや CPU 負荷の観点からも違いが現れます。

### ローカルステートとグローバルステートの違い

ローカルステートとは、各コンポーネント内部やその直近のサービスで管理される状態を指します。コンポーネントが破棄されると同時にその状態も破棄されるため、**ライフタイムがコンポーネント（ビュー）単位**で完結します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Local%20state))。一方、グローバルステートはアプリ全体で共有される状態で、一般的にアプリ起動から終了まで**アプリケーションのライフタイム全体**で保持されます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Global%20state))。NgRx ストアは典型的なグローバルステートであり、アプリが動作している間は基本的にストア内のデータは生き続けます。

この違いから、**メモリ負荷**について言えばローカルステートの方が不要になったデータを速やかに解放しやすいです。例えばあるコンポーネント内だけで使うオブジェクトをローカルステートで管理すれば、コンポーネント破棄とともにそのオブジェクトへの参照も無くなり、GC によりメモリから除去されます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=Local%20state))。逆にそれをグローバルステートに入れていた場合、コンポーネントを破棄してもストア上にデータが残り続け、意図的に削除しない限りメモリを占有し続けます ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。短命なデータはローカルに持つ方がメモリ効率的と言えます。

**CPU 負荷（パフォーマンス）**の面では、一概にどちらが有利とは言えませんがケースによります。ローカルステートはそのコンポーネントと子孫コンポーネントにだけ影響を与えるため、状態変更に伴う UI 再描画のコストが局所的ですみます。他の独立した画面には波及しないので、アプリ全体への影響を抑えられます。一方、グローバルステートの場合、状態変更が発生すると全ての購読中のコンポーネントに通知が飛びます。適切に**セレクタ**や`OnPush`を使っていれば実際に再レンダリングされるのは影響範囲のコンポーネントだけですが、それでもアプリ全体で単一のストアが変化するため、**大規模アプリでは一度の変更で多数の箇所が反応する可能性**があります。例えば大きなストアオブジェクトが丸ごと新しくなった場合、OnPush でないコンポーネントはすべて変更検知が走ってしまうかもしれません。こうした無駄を避けるにはストアを細かくスライスしてセレクタで最小限の部分だけ購読する工夫が必要です。

もう一つ CPU 面で言えば、**重い計算処理を伴う状態更新**の場合です。ある計算結果を算出して状態にセットする処理を複数コンポーネントでそれぞれ行うより、グローバルに一度計算して結果を共有した方が無駄な重複計算が減り CPU 負荷を下げられる場合があります。このように、グローバルステートは計算やデータ取得の一元化による効率化につながるケースもあります。一方、不要な頻度でグローバルな変更通知を出してしまうと逆効果になるため、**グローバルとローカルの使い分け**が大切です。

### アプリの規模による最適な選択肢

小規模なアプリケーションでは、必ずしもグローバル状態管理は必要ありません。コンポーネントごとにサービスや内部 state で状態を持ち回りして十分にシンプルに実装できる場合、NgRx のような大がかりな仕組みを導入するとかえってコード量や理解コストが増えます。ローカルステート中心であれば、使い終わったデータは画面破棄とともに自動でメモリから消えるためリークの心配も少なく、パフォーマンスチューニングも局所的に行いやすいでしょう。

一方、アプリが中〜大規模になり**複数のコンポーネント間で状態を共有する必要**が増えてくると、グローバルステート管理のメリットが大きくなります。例えばユーザーの認証情報やカートの内容など、アプリ全域で参照されるデータは一箇所（グローバルストア）で管理した方が一貫性が保ちやすく、各所へのデータ渡しもシンプルになります ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。グローバルストアを導入すると**「単一情報源 (Single Source of Truth)」**として状態を集中管理でき、バグの原因となる状態の不整合を減らせる利点があります ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL))。ただしその場合でも、**全てをグローバルに詰め込まない**ことが肝要です。先述のように局所的な状態は各コンポーネント内に留め、**本当にアプリ全体で必要なものだけ**をグローバルストアに置く設計にすると、メモリとパフォーマンスのバランスが良くなります。NgRx では最近**ComponentStore**という各コンポーネント専用の小さなステート管理機能も提供されており、グローバル Store と組み合わせて使うことで必要最小限のグローバル状態に留めることもできます。

以上を整理すると、**ローカル vs グローバル状態管理の選択**は以下の基準によると良いでしょう。

- **状態のスコープ**: 「このデータはアプリ全体で共有すべきか？特定の画面内だけで完結するか？」を判断します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,other%20views%20for%20example))。後者であればローカル管理で十分です。前者ならグローバルストアに置く価値があります。

- **ライフサイクル**: 「この状態はアプリ起動中ずっと必要か？一時的か？」を考えます。常に必要なもの（例:ログインユーザ情報）はグローバル、短期間で不要になるもの（例:一時的なフィルタ条件）はローカルが適しています ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,API%27s%2C%20Web%20Sockets%2C%20Browser%20URL)) ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,Parsing%20global%20state%20to%20local))。

- **共有の必要性**: 複数のコンポーネントやモジュールにまたがって参照・更新されるならグローバルに、単一 UI 内で閉じていればローカルに保持します ([Difference between Global and Local state | RxAngular](https://rx-angular.io/docs/state/recipes/determine-state-type#:~:text=,other%20views%20for%20example))。

- **性能面のコスト**: 計算コストの高い処理結果を色々な箇所で使うなら一度グローバルで計算共有した方が効率的です。逆に頻繁に変わる UI 状態（ユーザ操作で ON/OFF する UI 要素の状態など）をいちいちグローバルに上げると、無駄な通知が増えて重くなる可能性があります。

適切に判断すれば、ローカルとグローバル状態管理を組み合わせることでメモリと CPU の使用効率を最適化できます。例えば**「グローバル：ユーザや設定など長期間共有される状態」「ローカル：画面固有の一時的な状態」**と分離することで、必要十分なデータだけがメモリに残り続け、不要なものは破棄されるバランスの取れたアプリ設計となります。その上で NgRx のような仕組みを使えば大規模でも整然と状態管理できますし、逆に小規模なら無理に導入せずシンプルに保つ方が結果として軽量に動作するでしょう。

## ブラウザのメモリ許容量と PC スペック依存の関係

### ブラウザのメモリ最大使用量

Chrome や Edge などモダンブラウザは、64bit 環境では理論上非常に大量のメモリを扱えますが、**内部的にタブ（レンダラープロセス）毎のメモリ使用に上限**を設けています。Chrome では一つのレンダラープロセス（タブ）が使用できるメモリはおよそ**16GB**程度に制限されており、Edge も同様です ([Error code: Out of Memory - How to allocate more memory to Google Chrome - 64 GB ram available - Super User](https://superuser.com/questions/1675677/error-code-out-of-memory-how-to-allocate-more-memory-to-google-chrome-64-gb#:~:text=1,you%20hit%20the%2016G%20limit))。これは OS やブラウザ自体のアーキテクチャ上の制約によるもので、仮に PC に 2TB もの膨大な RAM を積んでいても、1 つのタブが 16GB 以上メモリを消費しようとすると**"Out of Memory"**エラーが発生してページがクラッシュします ([Error code: Out of Memory - How to allocate more memory to Google Chrome - 64 GB ram available - Super User](https://superuser.com/questions/1675677/error-code-out-of-memory-how-to-allocate-more-memory-to-google-chrome-64-gb#:~:text=1,you%20hit%20the%2016G%20limit))。この上限は以前は 4GB 前後（特に 32bit 版ではアドレス空間の制限で約 4GB）でしたが、近年の 64bit 版では拡張されました。ただし**16GB ものメモリを単一タブで使い切るケースは非常に稀**であり、通常はその前にユーザが不便を感じたり、PC 全体のメモリが不足したりするでしょう。

ブラウザ全体で見れば、開けるタブ数や利用可能なメモリ容量には実質上**PC の物理 RAM 容量**が上限となります。例えば 8GB RAM の環境では OS 自体やバックグラウンドプロセスが数 GB 使用するため、ブラウザに使えるメモリはせいぜい 4 ～ 5GB 程度です ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。一方 16GB 搭載なら 10GB 以上、32GB なら 20 数 GB と、搭載 RAM が多いほどブラウザが快適に使えるメモリも増加します ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。実際の計測では、Windows10 でメモリ 8GB の PC では「利用可能」メモリがおよそ 4.5GB だったのに対し、16GB では 12.3GB、32GB では 28GB がそれぞれ空きとして確保できていました ([2TB のメモリで Chrome のタブをどのぐらい開けるのか? - PC Watch](https://pc.watch.impress.co.jp/docs/news/yajiuma/1234738.html#:~:text=Linus%E6%B0%8F%E3%81%AF%E3%80%81%E3%80%8CCPU%E3%81%A8%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AF%E3%81%BE%E3%81%A0%E4%BD%99%E8%A3%95%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8C%E3%80%81Chrome%E3%81%BE%E3%81%9F%E3%81%AFOS%E3%81%A8%E3%81%84%E3%81%A3%E3%81%9F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E5%88%B6%E9%99%90%E3%81%8C%E3%81%95%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A0%E3%80%8D%E3%81%A8%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。つまり OS が占有する分を除けば、**残りは基本的にブラウザなどアプリが自由に使える**ので、RAM を増設すればその分だけ多くのタブを開いたり重いページを読み込んだりできる計算になります。

ただし物理メモリを超えてさらにブラウザがメモリを要求し続けると、OS はスワップ（ディスク上の仮想メモリ）を使い始めます。スワップは非常に遅いため、ディスクアクセスが発生し始めるとブラウザの動作は極端に重くなります。Chrome ではメモリ不足時にタブを自動的に破棄して再読み込みを促す措置（前述のタブ破棄）が取られることもありますが、ユーザが大量のタブを開きっぱなしにしていると OS 側で強制的にプロセスが落とされる（OOM Killer による終了）可能性もあります。いずれにせよ、**ブラウザの実質的な使用可能メモリ容量=PC の搭載 RAM - OS その他が使う分**と考えてよいでしょう。

### CPU スペックによる処理能力の変動

CPU の性能やコア数も、ブラウザのパフォーマンスに大きな影響を与えますが、**メモリ許容量そのものには直接的な変化を与えません**。例えば同じ 16GB RAM でも、低速な CPU では多数のタブを開いたときに処理が追いつかずカクついたり、GC に時間がかかってメモリ解放が遅れる可能性があります。一方、高性能な CPU（高速クロック・多コア）であれば、各タブの処理を並行してこなせるため、より多くのタブを快適に扱えるでしょう。Chrome や Edge はマルチプロセスなので、**コア数の多い CPU ほど複数タブを同時に動かすのに有利**です。例えば 8 コア CPU なら重いタブ 8 個まである程度スムーズに動作しますが、2 コア CPU だと 2 つ開いた時点で CPU リソースが飽和しやすくなります。

また CPU 性能が高いと**ガベージコレクションの実行も迅速**になるため、結果的にメモリリークに強くメモリ使用量を低めに抑えられる場合もあります。例えば同じ Web アプリを動作させても、遅い CPU では GC が追いつかず一時メモリ使用量が増える場面で、高速 CPU なら素早く不要メモリを回収できるかもしれません。ただし根本的なメモリの最大許容量は変わらないため、CPU さえ良ければ無制限にメモリを使えるわけではありません。

総合すると、**ブラウザのメモリ使用上限は主にソフトウェア制限(タブあたり約 16GB)と搭載 RAM 量に依存**し、CPU 性能は主として**処理速度や同時実行性**の面で寄与します。高性能な PC ほど多数のタブをスムーズに扱え、大容量 RAM ほど多くのデータをメモリ上に保持できます。逆に低スペックな PC では少数のタブでもメモリ逼迫や CPU 過負荷に陥りやすいため、Chrome では不要タブの自動破棄や Edge のスリープタブといった省資源機能が特に効果を発揮します ([Unlike Chrome, Microsoft Edge cares about RAM; sleeps 1.3 billion tabs in September | Windows Central](https://www.windowscentral.com/software-apps/unlike-chrome-microsoft-edge-cares-about-ram-sleeps-13-billion-tabs-in-september#:~:text=Despite%20Sleeping%20Tabs%20being%20built,based%20on%20system%20RAM%20levels))。開発者・ユーザ双方の視点で言えば、**自分の PC スペックに見合ったタブ数や Web アプリの設計**を心掛け、限られたリソースを有効活用することが大切です。

---

本調査により、メモリ管理の原理からブラウザ固有の挙動、NgRx 状態管理の工夫まで幅広く把握できました。適切なメモリ管理戦略を取ることで、不要なメモリ消費やリークを防ぎつつ、快適で効率的な Web アプリケーションを構築できるでしょう。NgRx を用いたグローバル状態管理では、必要なデータを適切に管理し、開発者ツールでメモリ挙動を監視することで、安全かつスケーラブルな状態管理が可能です。また Chrome や Edge といったブラウザのメモリ特性を理解することで、ユーザの利用環境に配慮したアプリの動作や、不具合発生時の的確なデバッグにつなげられるはずです。今後はこれら知見を踏まえて、より効率的な NgRx の活用とブラウザメモリ管理の最適化に取り組んでいきます。 ([メモリー管理 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Memory_management#:~:text=%E7%8F%BE%E5%9C%A8%E3%80%81%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%8F%BE%E4%BB%A3%E7%9A%84%E3%81%AA%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%83%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%9E%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%B3%E3%83%89%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%97%E5%BC%8F%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E9%81%8E%E5%8E%BB%E6%95%B0%E5%B9%B4%E9%96%93%E3%81%A7%20JavaScript%20%E3%81%AE%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88%E4%B8%96%E4%BB%A3%20%E5%88%A5%2F%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%2F%E4%B8%A6%E8%A1%8C%2F%E4%B8%A6%E5%88%97%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%89%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E6%94%B9%E5%96%84%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E6%94%B9%E5%96%84%E3%81%A7%E3%81%82%E3%81%A3%E3%81%A6%E3%80%81%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%87%AA%E4%BD%93%20%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%94%B9%E5%96%84%E3%81%A7%E3%82%82%E3%80%81%E3%80%8C%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%80%8D%E3%81%A8%E6%89%B1%E3%81%86%E5%9F%BA%E6%BA%96%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82)) ([Microsoft Edge vs Chrome: Which to Choose in 2025? | BrowserStack](https://www.browserstack.com/guide/edge-vs-chrome#:~:text=,and%20memory%20optimization%20in%202023))

ComponentStore と Signal の使い分けについて、以下の観点から詳しく調査しお伝えします。

1. **基本的な概念と特徴の違い**
   - ComponentStore（NgRx の一部）と Signal（Angular のリアクティブシステム）の役割
   - それぞれのメリット・デメリット
2. **パフォーマンス面での違い**

   - メモリ消費量や GC の影響
   - CPU 負荷と変更検知の最適化

3. **アプリの規模や要件に応じた適切な選択基準**

   - 小規模・中規模・大規模アプリでの使い分け
   - どのようなユースケースで ComponentStore が有効か？
   - どのようなユースケースで Signal が有効か？

4. **NgRx との併用に関するベストプラクティス**

   - ComponentStore と Signal の組み合わせ方法
   - NgRx のグローバルストアとの連携
   - State 管理の効率的な設計

5. **Angular の最新バージョンでの推奨される使い方**
   - 公式のベストプラクティス
   - 今後の Angular の方向性と Signal の役割
   - ComponentStore が今後も推奨されるか？

これらを包括的に調査し、最適な使い分け方を明確にお伝えします。調査完了次第、詳細を共有します。

# ComponentStore と Signal の使い分け調査

## 1. 基本的な概念と特徴の違い

**ComponentStore**（NgRx の一部）と**Signal**（Angular v16+で導入されたリアクティブシステム）は、ともに状態管理を支援しますが、その役割と適用範囲が異なります。

- **ComponentStore**は、**ローカルなコンポーネント状態**を管理するための NgRx ライブラリです。複数のインスタンスを作成でき、各コンポーネント単位で独立した状態を保持します。内部的には RxJS（BehaviorSubject や Observable）を用いて実装されており、小規模な Redux パターン（単一ソースの真実）をコンポーネントレベルで実現します。主に**UI やコンポーネント単位**で閉じた状態管理に適し、NgRx のグローバルストアを使うほどではない局所的な状態を扱う際に役立ちます。

- **Signals**は Angular フレームワークに組み込まれた**リアクティブステート管理の仕組み**です。値をラップし、その値が変更されたときに関連する消費先へ通知します。Signal は**同期的なゲッター**で値を読み出し（`mySignal()`のように関数呼び出し）、Angular はその読み出し箇所を追跡して、自動的に再レンダリングを最適化します。Signals には書き込み可能なもの（`WritableSignal`）と他の Signal から導出する読み取り専用のもの（`computed`シグナル）があります。Angular v16 以降のテンプレートでは、Signal を直接バインドすることで、従来の`async`パイプのように振る舞います（シグナルは読み出し時に自動で Change Detection を通知します）。

**メリット・デメリットの比較:**

- **ComponentStore のメリット:**

  - ローカルな状態管理に**構造と一貫性**をもたらします。NgRx Store（グローバル状態管理）の縮小版として、**エフェクト（副作用処理）やアップデート関数**などパターン化された API を備えています。複雑な状態更新や非同期処理も、RxJS のオペレーターや NgRx エコシステム（Effects など）と組み合わせて記述できます。
  - **疎結合**: ComponentStore はグローバルストアとは独立していますが、必要に応じて NgRx Store と併用可能です。例えばグローバルストアから一部の状態を取得してローカル状態として保持するなど、**ローカルとグローバルの橋渡し**にも使えます。

- **ComponentStore のデメリット:**

  - **RxJS の知識**が必要です。状態の更新や購読に RxJS パターン（Observable/Subscriber）が絡むため、学習コストがあります。簡単な状態管理にも Redux 的なボイラープレートが増える傾向があります。
  - グローバルな NgRx Store とは異なり、**Redux DevTools などで追跡**することが難しい（ローカル状態のため）という指摘もあります ([Lifecycle - NgRx](https://ngrx.io/guide/component-store/lifecycle#:~:text=While%20ComponentStore%20remains%20supported%2C%20we,considering%20migration%20for%20existing%20ones))。また、Angular Signals の登場により、「BehaviorSubject を使ったサービスパターン」と比較して限定的な優位性しかないとも言われています。

- **Signals のメリット:**

  - **シンプルで直感的**: 値を関数のように読み書きするだけでリアクティブになります。テンプレートに直接バインドすると、自動でその部分のビュー更新が行われます。RxJS のような購読管理や`async`パイプは不要で、メモリリークの心配も少なくなります（後述）。
  - **Angular と深く統合**: シグナルは Angular の Change Detection（変更検知）と統合されており、**どのコンポーネントで参照されているかフレームワークが追跡**します。その結果、必要な箇所だけを再描画する**最適化**が可能です。後述のように、OnPush 戦略の親コンポーネントもシグナル更新時にスキップできる（ローカルな CD）ため、パフォーマンス上の利点があります。
  - **学習コストが低い**: Angular 標準機能として導入されたため、追加ライブラリ不要で使えます。記法もシンプルなため、RxJS に不慣れな開発者でも扱いやすいです。Angular チーム自ら「状態やデータ保持には Signal を使い、RxJS はイベントや複雑なロジックに使うよう強く推奨する」と述べています ([Angular: RxJS vs Signals, what to use? | by Igor Pak - Medium](https://medium.com/@IgorPak-dev/angular-rxjs-vs-signals-what-to-use-17f2655b7e9c#:~:text=The%20Angular%20team%20strongly%20advises,handle%20events%20and%20complex%20logic))（Signals 重視の姿勢）。

- **Signals のデメリット:**
  - **非同期ストリーム処理の表現力**では RxJS に劣ります。Signal はあくまで現在値の保持と伝播が主目的で、複数の非同期ソースを合成したり、時間的なストリーム操作（例えば`debounceTime`や`mergeMap`等）をする場合、依然として RxJS が必要になる場面があります ([Skillfully Using Signals in Angular - Selected Hints for Professional ...](https://www.angulararchitects.io/en/blog/skillfully-using-signals-in-angular-selected-hints-for-professional-use/#:~:text=Skillfully%20Using%20Signals%20in%20Angular,asynchronous%20tasks%20and%20for))。実際 Angular の Signals は**同期的な状態伝播**が得意で、クリックイベントやタイマーなど非同期イベントを直接扱う場合は RxJS との橋渡しが必要です。
  - **パターンの確立途上**: 新機能のため、従来の NgRx やサービス+Observable パターンに比べて大規模開発での実績が少ないです。特に大規模アプリで複数開発者が関与する場合、Signal だけで一貫したアーキテクチャを設計するノウハウは発展途中といえます。

### 基本概念のまとめ（比較表）

| 観点             | ComponentStore (NgRx)                                                                                              | Signals (Angular 標準)                                                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **役割・用途**   | ローカルなコンポーネント状態管理。<br>サービス+BehaviorSubject パターンの代替。                                    | コンポーネントやサービス内でのリアクティブな値管理。<br>Angular 組込のリアクティブプリミティブ。                                                          |
| **実装技術**     | RxJS（Subject/Observable）。<br>NgRx ストアに類似した API（`setState`や Effect など）。                            | Angular Signals API（`signal()`, `computed()`, `effect()`など）。RxJS は不要（必要なら併用）。                                                            |
| **メリット**     | _構造化_：状態変更パターンが統一され、予測可能。<br>_エンタープライズ実績_：NgRx エコシステムの一部で信頼性高。    | _簡潔_：コード量削減、直接バインドで自動 CD。<br>_高効率_：Angular が依存追跡し不要な検知をスキップ。<br>_安全_：購読解除漏れがなくメモリリークしにくい。 |
| **デメリット**   | _複雑さ_：RxJS 習熟が必要、ボイラープレート多め。<br>_追加依存_：外部ライブラリ(NgRx)導入が必要。                  | _限定性_：高度な非同期ストリーム操作が苦手（RxJS 併用が必要）。<br>_新規格_：知見が浅く、旧来パターンとの混在時に戸惑う可能性。                           |
| **適用シーン例** | フォームウィザード等、**複雑な局所状態**を持つコンポーネント。<br>グローバル状態から切り離せる UI 固有状態の管理。 | フィルタや入力値など**頻繁に変化する UI 状態**。<br>小規模機能の状態管理、簡易なグローバル状態（サービス内で Signal を用いる場合）                        |

## 2. パフォーマンス面での違い

**メモリ消費量や GC（ガベージコレクション）**の観点では、一般に**Signals のほうが効率的**とされています。一部の検証では、「メモリ効率の明確な勝者は Signals だった」と報告されています ([Signals vs RxJs performance implications : r/Angular2](https://www.reddit.com/r/Angular2/comments/1h9pecf/signals_vs_rxjs_performance_implications/#:~:text=Last%20time%20the%20clear%20winner,if%20you%20have%202%20minutes))。Signal は現在の値を 1 つ保持するだけであるのに対し、RxJS の Observable チェーンはオブジェクトやクラス（演算子ごとのインスタンスなど）を多数生成しがちで、これがメモリ使用量や GC の負荷に影響します。実際、ある比較では**Signal は同等の RxJS 実装よりもメモリフットプリントが小さい**結果が得られています ([Signals vs RxJs performance implications : r/Angular2](https://www.reddit.com/r/Angular2/comments/1h9pecf/signals_vs_rxjs_performance_implications/#:~:text=Last%20time%20the%20clear%20winner,if%20you%20have%202%20minutes))。一方で別の解析によれば、単純な`BehaviorSubject`一つと Signal 単体を比べると、Signal オブジェクトのほうがやや大きい（約 1.5 倍）というデータもあります。この差は Signal が内部で依存関係追跡や change detection フックを持つためですが、**現実的なシナリオでは Signal の方が中間オブジェクトを増やさずメモリリークもしにくい**ため、総合的なメモリ効率は優れているケースが多いと言えます。

**GC（ガベージコレクション）とメモリリーク**について見ると、Signal は**購読という概念がなく、Angular フレームワークが参照を管理**するため、RxJS に比べてメモリリークが発生しにくいです。RxJS では開発者が Observable を購読し、不要になれば`unsubscribe`する必要がありますが、忘れるとメモリリークにつながります。Signal では値への参照が自動的にトラッキングされ、コンポーネント破棄時に参照もクリーンアップされます（Angular が責任を持っている）。そのため、「Signal でメモリリークを起こす方が RxJS よりずっと難しい」と言われるほど、**リソース管理が自動化**されています。

**CPU 負荷と変更検知（Change Detection）**の最適化では、Signal は Angular に最適化された動作をします。**Observable**の場合、値が発行されるとその都度同期的に購読処理が走り、`async`パイプ経由であれば該当コンポーネントを`markForCheck`して Change Detection をスケジューリングします。複数の Observable 更新が短時間に発生すると、その回数分だけチェックが走る可能性があります（手動で`distinctUntilChanged`等を適用しない限り）。一方、**Signal**の場合、更新通知は**フレームワークによってスケジューリング**され「最終的には」実行されます。つまり、**同じフレーム中で Signal が何度も更新されても、変更検知サイクルはまとめて 1 回だけ行われる**可能性があります。このように Signal の再計算は**非同期的にバッチ処理**され、不要な再描画を間引くことがあります。加えて、Signal が引き起こす Change Detection では**“ローカル変更検知”**とも呼ばれる最適化が働き、OnPush の親コンポーネントをスキップして子コンポーネントだけを更新することが可能です。Angular v17 で導入予定の機能も含め、シグナルを用いた場合は**影響範囲のコンポーネントのみを効率よく再チェック**する仕組みが整えられています。

具体的に、ある Reddit での検証報告では以下のような指摘があります:

- **Observable**: 値を発行すると即座に同期的に計算・伝播される。購読中の Observable では**発行される全ての値に対し再計算**が走る。
- **Signal**: 値の変更による再計算は**非同期的にスケジュール**される。同じタイムフレーム内で複数回更新があった場合でも、古い値で無駄な再計算をスキップし、**最後の値に基づいて 1 度だけ処理**する（値が一部スキップされ得る）。これは消費側（Signal を読み出すテンプレートや computed）が主導で計算を行う仕組みのためで、結果として処理が最適化される。

以上より、**CPU 面のパフォーマンス**は Signal・Observable いずれも「非常に高速」であり、実用上大差ないという報告もあります ([Signals vs RxJs performance implications : r/Angular2](https://www.reddit.com/r/Angular2/comments/1h9pecf/signals_vs_rxjs_performance_implications/#:~:text=Last%20time%20the%20clear%20winner,if%20you%20have%202%20minutes))。極端なケースでなければどちらでも十分高速ですが、Signal の仕組みによる**無駄な再描画削減**や**効率的なバッチ処理**は、大規模なコンポーネントツリーで UI スムーズさを向上させる可能性があります。

## 3. アプリ規模や要件に応じた適切な選択基準

アプリケーションの規模やチーム要件によって、ComponentStore と Signal、あるいは NgRx ストアを適材適所で使い分けることが重要です。一般的なガイドラインとして、**小規模**・**中規模**・**大規模**アプリケーションでは次のような選択が推奨されます:

- **小規模アプリ**（画面数や状態が限定的）: 専用の状態管理ライブラリを使わず、**シンプルなサービス+Observable**もしくは**Signal**で十分対応できます。例えば、サービス内で`BehaviorSubject`を用いて状態を保持したり、Angular v16+であれば`signal()`を使ってサービスやコンポーネント内に状態を持たせる方法です。NgRx などはオーバーヘッドが大きくなるため、この段階では避けるのが無難です。Signal はシンプルな実装でコンポーネントの UI 状態を管理できるため、小規模アプリでは特に有効です。

- **中規模アプリ**（画面や機能が増えてきた段階）: **Signals**の活用が推奨されます。Signal を使うことでコンポーネント間のデータ共有や状態の一元管理が比較的容易に行えます。例えば、複数コンポーネントで共有する必要のある状態はサービスで`WritableSignal`として保持し、各所でそれを読み取るといった実装です。これにより状態変更時には関係するコンポーネントだけが更新され、高頻度な UI 更新にも効率的に対応できます。**ComponentStore**もこの規模で採用されることがありますが、Angular v16 以降では「まず Signals を検討し、特別な理由がなければ ComponentStore に頼らなくても良い」という傾向です。ComponentStore は RxJS ベースで強力ですが、中規模程度までのアプリであれば Signal とサービスで十分賄えるケースが増えています。

- **大規模アプリ**（多数の画面、複数チームでの開発、複雑な状態管理）: **NgRx Store**のようなグローバル状態管理ライブラリの使用が検討されます。アプリ全体の単一ソースの真実（Single Source of Truth）を維持し、厳格なパターン（Redux パターン）で状態変更を管理することで、可読性・メンテナンス性・デバッグ効率を高めるためです。NgRx Store は**タイムトラベルデバッグ**や**開発者ツール連携**、**エフェクトによる副作用管理**など大規模開発を支える機能が豊富です。もっとも、Angular v16+では NgRx も Signals と統合が進んでおり、ストアから直接 Signal を選択できる API（`selectSignal`）が提供されています ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Component%28,Store))。大規模アプリでも、コンポーネント側では Signal として状態を扱うことで、パフォーマンスと開発効率を両立することが可能です。

**ユースケースごとの使い分け:**

- **ComponentStore が有効なケース:** コンポーネント単位で状態とロジックを切り離し、かつ**RxJS の高度な組み合わせ**を用いて処理したい場合に適しています。例えば、あるコンポーネント内で入力フォームの状態管理や一連の非同期処理（サーバー問い合わせ → 結果の加工 → 状態反映）を完結させたい場合、ComponentStore 内に状態（ステート）とエフェクト（副作用）を定義することで実現できます。既存プロジェクトで既に NgRx Store を使っている場合、その延長でローカル状態管理に ComponentStore を導入すると**開発者になじみやすく**移行コストが低いという利点もあります。また**Angular v16 未満**では Signal が無いため、そうした環境では ComponentStore が事実上ベストな選択肢でした。

  _例:_ 大量のフォーム要素を持つ複雑なダイアログで、一時的な入力内容を管理しつつ、保存時にのみグローバルストアに反映するような場合。入力中は ComponentStore でローカルに状態管理し、確認・保存時に NgRx Store のアクションを dispatch することでグローバル状態に反映、といった構成が可能です。このように、**一時的または局所的に閉じた複雑状態**に ComponentStore は有効です。

- **Signal が有効なケース:** ユーザー操作に応じて**頻繁に変化する UI 状態**を扱う場合や、**リアルタイムに近い更新**が求められる場合に特に有効です。Signal は変更が直接テンプレートの再描画につながるため、カウンターやフィルター入力、トグルのオンオフなど、素早く反映したい UI 要素の状態管理に適しています。シンプルな状態であればそのままコンポーネント内に`signal()`で保持し、少し広い範囲で共有したければサービスで Signal を公開するとよいでしょう。さらに、Signal は**計算プロパティ（computed）**を簡潔に定義できるため、他の状態から派生する値（例: 複数のフィルター Signal から導出した結果リストなど）の管理にも向いています。RxJS で`combineLatest`や`map`を駆使していた処理が、computed シグナルで同期的な関数定義を書くだけで実装できる場合も多いです。

  _例:_ ユーザーが入力する検索クエリに応じてリストをフィルタリング表示するコンポーネントで、クエリ文字列を Signal で保持し、それに依存した filteredList を computed シグナルで計算する。ユーザー入力ごとにビューが更新されますが、Signal により必要な部分のみ効率よく再描画され、高速に応答します。

要約すると、「**できるだけローカルに状態を閉じ込め、必要になった時だけスコープを広げる**」のが効率的な設計です。小・中規模の範囲では Signal や ComponentStore で局所状態を管理し、どうしてもアプリ全域で共有すべき状態のみグローバルストア（NgRx Store など）に乗せると、コードの見通しとパフォーマンスのバランスが良くなります。

## 4. NgRx との併用に関するベストプラクティス

**NgRx（グローバルストア）**と**Signals/ComponentStore（ローカル状態管理）**は併用が可能であり、適切に組み合わせることで双方の利点を享受できます。

- **ComponentStore と Signal の組み合わせ:** Angular v16 時点では、ComponentStore 自体は RxJS ベースですが、**コンポーネントでは Signal を使う**というハイブリッドも可能です。例えば、ComponentStore が内部で管理する`Observable state$`を`toSignal()`関数で Signal に変換し、テンプレートバインディングには Signal 経由で使うといった方法です。逆に、Signal で保持したローカル状態を`effect()`で監視し、変化時に ComponentStore の`setState`や`アップデート`メソッドを呼ぶこともできます。しかしながら**Angular 公式は将来的にローカル状態管理には Signal ベースのアプローチを推奨**しており、NgRx もそれに沿った新機能を提供し始めています（後述の Signal Store など） ([Comparison of ComponentStore and Store - NgRx](https://ngrx.io/guide/component-store/comparison#:~:text=While%20ComponentStore%20remains%20supported%2C%20we,considering%20migration%20for%20existing%20ones))。そのため、**新規プロジェクトでは ComponentStore ではなく Signal（または Signal Store）を採用**し、既存で ComponentStore を使っている場合も必要に応じて移行を検討するとよいでしょう ([Comparison of ComponentStore and Store - NgRx](https://ngrx.io/guide/component-store/comparison#:~:text=While%20ComponentStore%20remains%20supported%2C%20we,considering%20migration%20for%20existing%20ones))。

- **NgRx グローバルストアとの連携:** NgRx（@ngrx/store）は大規模アプリで強力ですが、Angular v16 以降では**ストアから直接 Signal を取得する API**が追加されています ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Component%28,Store))。`Store.selectSignal(selector)`を使うことで、NgRx ストア内の任意のセレクタ（状態の一部）を Signal として参照できます ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Component%28,Store))。これにより、コンポーネント側ではストアの値をまるで Signal のように読み出せるため、`async`パイプなしでテンプレートのバインディングが可能になり、パフォーマンスも向上します。以下にコード例を示します ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Component%28,Store)):

  ```ts
  // グローバルストアからSignalを選択
  this.flights = this.store.selectSignal(ticketingFeature.selectFlights);
  // Signalの値を読み取ってアクションに利用
  this.store.dispatch(
    ticketingActions.loadFlights({
      from: this.criteria().from,
      to: this.criteria().to,
    })
  );
  ```

  このように、**グローバルストアの状態を Signal として扱う**ことで、ComponentStore がなくとも**ローカル状態と同様の開発体験**が得られます。さらに、NgRx の最新バージョンでは Signal に対応したストア拡張（Signal Store）が登場しており、RxJS と Signals の橋渡しがよりシームレスになっています ([Announcing NgRx v17: Introducing NgRx Signals, Operators, Performance Improvements, Workshops, and more! - DEV Community](https://dev.to/ngrx/announcing-ngrx-v17-introducing-ngrx-signals-operators-performance-improvements-workshops-and-more-55e4#:~:text=NgRx%20ComponentStore%20was%20built%20to,no%20plans%20to%20deprecate%20it))。

- **状態管理の効率的な設計（Facade パターンなど）:** NgRx ストアを直接コンポーネントで扱うと、セレクタやディスパッチの記述が分散しがちです。これを緩和するために**Facade（ファサード）サービス**を導入するのがベストプラクティスの一つです ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=Option%205%3A%20Hiding%20the%20Store,Behind%20a%20Facade))。Facade サービスは、内部で Store や HTTP サービスなどにアクセスしつつ、外部にはドメイン特化のシグナルやメソッドを提供します ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Injectable%28,Store))。例えば、`FlightBookingFacade`が`flights`という Signal や`loadFlights()`というメソッドを公開し、その中で Store への`dispatch`を行うといった形です ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=%40Injectable%28,Store)) ([Angular Signals & Your Architecture: 5 Options - ANGULARarchitects](https://www.angulararchitects.io/en/blog/angular-signals-your-architecture-5-options/#:~:text=load%28%29%3A%20void%20,%29%3B))。コンポーネント側は Facade 経由で状態取得・変更を行うため、NgRx 特有の実装詳細（アクションやセレクタ）から切り離され、テストや再利用も容易になります。

  また、**Signals と RxJS の相互運用**も重要なポイントです。例えば、ユーザー入力 Signal を監視してサーバー問い合わせをする場合、`signal`→`toObservable()`で RxJS のパイプに渡し、`switchMap`で HTTP コールし、結果を再度`toSignal()`で Signal にセットするといった流れになります ([Angular Signals: What's the proper way to trigger a fetch when input ...](https://stackoverflow.com/questions/78135603/angular-signals-whats-the-proper-way-to-trigger-a-fetch-when-input-signals-cha#:~:text=Angular%20Signals%3A%20What%27s%20the%20proper,result%20back%20to%20a%20signal))。Angular は`rxjs-interop`というユーティリティを提供し、Signal と Observable 間の変換を簡単にしています ([Angular Signals: What's the proper way to trigger a fetch when input ...](https://stackoverflow.com/questions/78135603/angular-signals-whats-the-proper-way-to-trigger-a-fetch-when-input-signals-cha#:~:text=Angular%20Signals%3A%20What%27s%20the%20proper,result%20back%20to%20a%20signal))。このように、**イベントストリームは RxJS、状態保持と UI 反映は Signal**というすみ分けも可能で、両者の強みを活かす設計がベストプラクティスとなりつつあります。

要するに、**グローバルな状態は NgRx ストア＋ Signal、ローカルな状態は Signal（あるいは必要に応じ ComponentStore）**という併用パターンが現状の最適解と言えます。Signals によってコンポーネントの再描画効率は上がり、NgRx は全体構造の一貫性と強力なデバッグ性を提供するため、両者を適切に使い分けることでスケーラブルかつパフォーマントなアプリ設計が可能です。

## 5. Angular 最新バージョンでの推奨される使い方

Angular の最新動向を見ると、**Signal 重視の方向性**が明確になっています。Angular 公式ドキュメントでも Signals は「アプリケーション全体で状態がどこで使われているか細かく追跡し、レンダリング更新を最適化できる仕組み」として紹介されており、今後フォームや他の機能とも密に連携していく計画が示唆されています（Angular チームはテンプレートの二重バインディングやフォーム API を Signal 対応に改善予定と公言しています）。実際、Angular v17 ではシグナルを用いたローカル変更検知の強化など、フレームワークレベルでの最適化が進んでいます。将来的には**Zone.js に依存しないシグナル中心の変化検知**も検討されており、Signals は Angular のコア機能として発展していく見込みです。

**公式のベストプラクティス:** Angular チームおよび NgRx チームは、**新規プロジェクトにおいては Signal ベースの状態管理を第一候補に**挙げています。NgRx のドキュメントでは「ComponentStore はサポート継続するが、新規プロジェクトでは@ngrx/signals の使用を推奨し、既存プロジェクトでも移行を検討してほしい」と明記されています ([Comparison of ComponentStore and Store - NgRx](https://ngrx.io/guide/component-store/comparison#:~:text=While%20ComponentStore%20remains%20supported%2C%20we,considering%20migration%20for%20existing%20ones))。これは、NgRx 自体が Signals を取り入れた「Signal Store」機能をリリースし、従来の ComponentStore や場合によっては NgRx Store に対してもシグナルを活用できるよう舵を切ったためです ([Announcing NgRx v17: Introducing NgRx Signals, Operators, Performance Improvements, Workshops, and more! - DEV Community](https://dev.to/ngrx/announcing-ngrx-v17-introducing-ngrx-signals-operators-performance-improvements-workshops-and-more-55e4#:~:text=NgRx%20ComponentStore%20was%20built%20to,no%20plans%20to%20deprecate%20it))。  
また、前述したように Angular チームも「状態管理には Signals を使い、RxJS は複雑な非同期処理に限定する」というガイドラインを示しており、公式ブログやコミュニティでも Signals を使った設計パターンが数多く紹介されています。

**今後の Angular の方向性と Signal の役割:** Signals は今後の Angular における**リアクティブプログラミングの中核**となる可能性があります。既に v16 で導入され、v17 で強化が進んでいることから、さらなるユースケース（フォームバリデーション、路線的にはコンポーネントの新しい記述方法など）への拡張が期待されます。シグナルは「シンプルなデータフローでパフォーマンスを最大化する」思想に基づいており、これは大規模アプリでも有用です。たとえば、**Angular Signals + NgRx**という構成で、グローバル状態管理をより効率よく行う事例が今後増えるでしょう。NgRx v17 で導入された**Signal Store**は、ComponentStore の良い部分（構造化された状態操作）と Signals の性能・簡潔さを融合したアプローチであり、開発者からフィードバックを集めつつ進化中です。このような動きから、Angular エコシステム全体が Signals を軸に再編成されつつあるといえます。

**ComponentStore は今後も推奨されるか？** NgRx チームの声明によれば、**ComponentStore は廃止予定はなく**既存アプリで引き続き価値を提供します ([Announcing NgRx v17: Introducing NgRx Signals, Operators, Performance Improvements, Workshops, and more! - DEV Community](https://dev.to/ngrx/announcing-ngrx-v17-introducing-ngrx-signals-operators-performance-improvements-workshops-and-more-55e4#:~:text=NgRx%20ComponentStore%20was%20built%20to,no%20plans%20to%20deprecate%20it))。特に既に安定運用しているエンタープライズアプリでは、すぐに新しい Signal Store へ置き換える必要はありませんし、ComponentStore 自体が「バトルテスト済み」で信頼性が高いことから当面は使い続ける選択も尊重されています ([Announcing NgRx v17: Introducing NgRx Signals, Operators, Performance Improvements, Workshops, and more! - DEV Community](https://dev.to/ngrx/announcing-ngrx-v17-introducing-ngrx-signals-operators-performance-improvements-workshops-and-more-55e4#:~:text=NgRx%20ComponentStore%20was%20built%20to,no%20plans%20to%20deprecate%20it))。しかし、新規開発や将来を見据えたリファクタリングにおいては、NgRx チーム自身が Signal への移行を促しているように、**事実上の第一選択肢は Signal（もしくは Signal を用いた NgRx Signal Store）**になるでしょう ([Comparison of ComponentStore and Store - NgRx](https://ngrx.io/guide/component-store/comparison#:~:text=While%20ComponentStore%20remains%20supported%2C%20we,considering%20migration%20for%20existing%20ones))。コンポーネント設計の観点でも、Signal はテンプレートとの親和性が高いため今後は推奨度が増すと考えられます。

以上の調査より、**ComponentStore と Signal の最適な使い分け**についてまとめると:

- ローカル状態管理には Angular Signals を活用し、UI 反応性とコード簡潔性を高める。
- グローバルかつ複雑な状態管理には NgRx ストアを採用し、必要に応じて Signal と統合して効率化する（NgRx Selectors→Signals や Signal Store の活用）。
- 既存の ComponentStore は無理に置き換えずとも良いが、新しい部分やアップデートでは Signal ベースの実装を検討する。

これらの指針に沿って技術選択を行うことで、最新の Angular の恩恵を受けつつ、アプリ規模に応じた適切な状態管理を実現でき、より効率的な Angular アプリ開発に役立てることができるでしょう。

**参考資料:** Angular 公式ドキュメント、NgRx 公式ガイド、コミュニティのベストプラクティス記事 ([Announcing NgRx v17: Introducing NgRx Signals, Operators, Performance Improvements, Workshops, and more! - DEV Community](https://dev.to/ngrx/announcing-ngrx-v17-introducing-ngrx-signals-operators-performance-improvements-workshops-and-more-55e4#:~:text=NgRx%20ComponentStore%20was%20built%20to,no%20plans%20to%20deprecate%20it))など。

了解しました！

RxJS の仕組みについて、以下の観点から詳しく調査し、実際の実装についても掘り下げます。

1. **基本概念（Observable、Observer、Subscription の仕組み）**

   - Observable とは何か？どのようにデータを流すのか？
   - Observer との関係性（next, error, complete）
   - Subscription の仕組みと内部の実装構造

2. **ストリーム処理（map, filter, mergeMap, switchMap などのオペレーター）**

   - 代表的なオペレーター（map, filter, mergeMap, switchMap）の動作
   - それぞれの内部実装とデータの流れ
   - 各オペレーターの実装の違い（特に mergeMap と switchMap の詳細）

3. **非同期処理（Promise との違い、スケジューラの仕組み）**

   - Promise との違い（同期・非同期の扱い）
   - RxJS におけるスケジューラ（queueScheduler, asyncScheduler など）の仕組みと役割
   - スケジューラを用いた処理の制御（マルチスレッドとの関係）

4. **メモリ管理とパフォーマンス（購読解除、メモリリーク対策）**

   - 購読解除の仕組み（unsubscribe の動作）
   - メモリリークの原因（購読解除忘れ、Subject の取り扱いミスなど）
   - RxJS のメモリ最適化テクニック

5. **実践的な使い方（Angular での適用、NgRx との組み合わせ）**

   - Angular の`HttpClient`との連携（RxJS を用いた非同期処理）
   - NgRx における RxJS の活用方法（Effects や Store のストリーム処理）
   - 実践的なサンプルコード

6. **RxJS の内部実装（ストリーム処理や購読処理の実装）**
   - Observable の内部でどのようにデータが流れるのか？
   - `subscribe`がどのように処理されるのか？
   - 各オペレーターの内部実装の概要（特に mergeMap, switchMap の内部処理）

調査が完了次第、詳細なレポートをお伝えします！

# RxJS の仕組みと内部実装の詳細

## 1. 基本概念（Observable、Observer、Subscription の仕組み）

**Observable（オブザーバブル）**は、時間の経過とともに複数のデータ（値）を発行できるストリームを表すオブジェクトです。`Observable`は「将来に渡って複数の値を順次送り出せる」点で Promise と異なります ([angular - What is the difference between Promises and Observables? - Stack Overflow](https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables#:~:text=Promise%20,will%20either%20reject%20or%20resolve))。**Observer（オブザーバー）**は Observable から送られる通知を受け取る契約で、`next`・`error`・`complete`という 3 種のコールバック（ハンドラ）を持つオブジェクトです ([RxJS 公式 Overview 要約(備忘録) #JavaScript - Qiita](https://qiita.com/UHNaKZ/items/1d0f1bc2dd0b4f539d1d#:~:text=const%20observer%20%3D%20,h%28%29%2C%2F%2Fsubscribe%E3%81%8C%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E6%99%82%E3%81%AE%E5%87%A6%E7%90%86))。`next`は値の通知、`error`はエラー発生時、`complete`は完了時の通知を処理します。Observable に対して`observer`を登録（購読）するには、`observable.subscribe(observer)`を呼び出します ([RxJS 公式 Overview 要約(備忘録) #JavaScript - Qiita](https://qiita.com/UHNaKZ/items/1d0f1bc2dd0b4f539d1d#:~:text=))。

**Subscription（サブスクリプション）**は購読の結果得られるオブジェクトで、購読処理そのものを表す「後片付け可能なリソース」です ([What is .subscribe in Angular? - Stack Overflow](https://stackoverflow.com/questions/44921788/what-is-subscribe-in-angular#:~:text=A%20Subscription%20is%20an%20object,Subscription%20has%20one%20important))。`subscribe()`メソッドは`Subscription`を返し、このオブジェクトの`unsubscribe()`メソッドを呼ぶと Observable の実行をキャンセルできます ([What is .subscribe in Angular? - Stack Overflow](https://stackoverflow.com/questions/44921788/what-is-subscribe-in-angular#:~:text=A%20Subscription%20is%20an%20object,Subscription%20has%20one%20important))。例えば非同期処理中の HTTP リクエストであれば、`unsubscribe()`により途中で結果を受け取るのを止めることが可能です。Subscription は内部的に購読時に登録されたクリーンアップ処理を保持し、`unsubscribe()`時にそれを実行してリソース（例えばタイマーやイベントリスナー）を解放します。また、Subscription は複数の購読をまとめて管理でき、子 Subscription を追加すると`unsubscribe()`時に子もまとめて解除されます。

**Observable と Observer の関係:** 開発者は通常、`new Observable((observer) => {...})`といった形で Observable を作成し、その中で`observer.next(...)`等を呼んで値や完了を通知します。一方で Observable はデフォルトでは**コールド**（遅延実行）であり、誰かが`subscribe`しない限り動き出しません。`subscribe()`が呼ばれると初めて“**Observable の実行**”が始まり、Observer に対して値やイベントが配信されます ([Hands-on-1: Create an Observable - vitainbeta](https://www.vitainbeta.org/hands-on-1-create-an-observable/#:~:text=Every%20time%20we%20call%20%C2%A0,dev))。**重要な点として、各`subscribe()`呼び出しは独立した実行を開始し、複数回購読すれば複数の実行がそれぞれ行われます ([Hands-on-1: Create an Observable - vitainbeta](https://www.vitainbeta.org/hands-on-1-create-an-observable/#:~:text=Every%20time%20we%20call%20%C2%A0,dev))**。例えば 1 つの Observable を 2 人が購読すれば、データの流れはそれぞれ個別に起こります（コールド Observable の場合）。

**内部実装の概略:** `Observable`のコンストラクタには購読時に実行する処理（関数）を渡します。`subscribe()`が呼ばれると、この関数が実行されますが、その前に RxJS 内部で`Subscriber`という Observer をラップしたオブジェクトが生成されます ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=%2F%2F%20Subscriber%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%81%8C%E4%BD%9C%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%20subscribe%28observerOrNext%3F%3A%20Partial,trySubscribe%28subscriber%29%29%3B%20return%20subscriber%3B))。その Subscriber が Observer（購読者）の`next`/`error`/`complete`ハンドラを内包しており、コンストラクタで指定した関数に渡されます ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1,next%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%80%82next%E5%86%85%E9%83%A8%E3%81%A7subscribe%E3%81%AE%E5%BC%95%E6%95%B0%E3%81%AE%E9%96%A2%E6%95%B0%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%80%82))。コンストラクタで渡した関数内で`subscriber.next()`を呼ぶと、内部的に購読者が提供した`next`コールバックが実行されます ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1,next%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%80%82next%E5%86%85%E9%83%A8%E3%81%A7subscribe%E3%81%AE%E5%BC%95%E6%95%B0%E3%81%AE%E9%96%A2%E6%95%B0%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%80%82))。簡単に言うと、**`subscribe`を呼ぶ -> RxJS が Subscriber を作成 -> Observable 内部の処理を実行し Subscriber に値を渡す -> Subscriber 経由で Observer のコールバックが呼ばれる**、という流れになります。

## 2. ストリーム処理（map, filter, mergeMap, switchMap などのオペレーター）

**オペレーター**は Observable のストリームに対して変換やフィルタリング、別のストリームとの結合など様々な操作を行う関数です。RxJS では`observable.pipe(operator1(), operator2(), ...)`のようにチェーンして使います。代表的なオペレーターである`map`や`filter`は**一対一変換**を行い、`mergeMap`や`switchMap`は**高次の Observable を平坦化**する（Observable が出す Observable を扱う）オペレーターです。それぞれの動作と内部処理の概要は以下の通りです。

- **map**: Array の`map`と同様に各要素を別の値に写像します。**入力された各値に対して関数を適用し、その結果を次の Observable に送出する**オペレーターです ([map - RxJS](https://rxjs.dev/api/operators/map#:~:text=Similar%20to%20the%20well%20known,projection%20in%20the%20output%20Observable))。例えば`source$.pipe(map(x => x*2))`では、`source$`から流れてくる値それぞれを 2 倍にして下流へ流します。内部実装としては、新たな Observable を生成し、その`subscribe`内で**元の Observable に購読**して`next`値を受け取るたびに指定の関数（project 関数）を適用し、結果を下流の Observer に`next`します ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=%2F%2F%20source.subscribe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7of%E3%81%AE%E5%80%A4%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%20source.subscribe%28%20operate%28,))。エラーや完了もそのまま下流に転送します。要するに「**subscribe 時に元 Observable を購読し、来た値を変換して次に流す**」処理が行われます。

- **filter**: 各値を与えられた述語（predicate）で評価し、**条件を満たした値だけを通過させる**オペレーターです ([Rxjs Filtering Operators — Getting Specific Values | by John Au-Yeung](https://javascript.plainenglish.io/rxjs-filtering-operators-getting-specific-values-9e790ee729a2#:~:text=Rxjs%20Filtering%20Operators%20%E2%80%94%20Getting,returned%20by%20a%20predicate%20function))。例えば`source$.pipe(filter(x => x % 2 === 0))`は偶数の値のみを通過させます。内部では`map`同様に新たな Observable を作り、元 Observable からの`next`値に対して predicate 関数を適用します。結果が`true`の場合にのみ下流に`next`で値を送り、`false`の場合はその値を無視します。`complete`や`error`は条件に関係なく伝播します。つまり「**条件を満たさない値を捨てる**」フィルタ処理が実装されています ([RxJS Transformation Operators' Implementation | by Amit Dhiman | Stackademic](https://blog.stackademic.com/rxjs-transformation-operators-implementation-36dddf3ba7d9#:~:text=In%20this%20example%2C%20we%20use,that%20satisfy%20the%20filtering%20condition))。

- **mergeMap（flatMap）**: 高階の Observable を扱う**flattening（平坦化）**オペレーターの一つです。**入力の各値を Observable にマッピングし、そのすべての内部 Observable から出た値をマージして一つの Observable として出力**します ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=This%20operator%20is%20best%20used,the%20number%20of%20inner%20subscriptions))。例えば`source$.pipe(mergeMap(x => makeRequest(x)))`では、`source$`の各値に対して HTTP リクエスト Observable を返し、複数のリクエスト結果を同時進行で受け取って下流に流します。**内部実装のポイントは、`source`から値を受け取るたびに`project`関数で新たな Observable（inner）を生成し、それに`subscribe`する**ことです。その際、以前から実行中の inner Observable があっても**キャンセルせず**そのまま並行して動き続けます。複数の inner Observable による通知は受け取った順序で下流 Observer にそのまま流されます。RxJS 内部では`mergeMap`は**同時に複数の内部購読を保持**できるようになっており（デフォルト無制限、オプションで同時実行数を指定可能）、各 inner から届く`next`を下流へ即座に渡します。例えば HTTP リクエストのように「発行した全てのリクエスト結果を欠かさず受け取りたい（キャンセルしない）」ケースでは`mergeMap`が適しています ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=For%20instance%2C%20when%20using%20switchMap,73%20is%20a%20better%20option))。一方、内部の Observable が完了するまで順番に次を処理したい場合は`concatMap`、最新のものだけ必要な場合は次の`switchMap`を使うべきです ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=For%20instance%2C%20when%20using%20switchMap,73%20is%20a%20better%20option))。

- **switchMap**: こちらも高階 Observable を扱うオペレーターですが、その動作は`mergeMap`と対照的です。**`switchMap`は新しい値が来るたびに以前の内部 Observable を即座に購読解除（キャンセル）し、常に最新の内部 Observable からの値だけを出力します ([Simple Angular Debounce using RxJS | Clear Blue Design](https://m.clearbluedesign.com/how-to-simple-angular-debounce-using-rxjs-e7b86fde6167#:~:text=%3E%20switchMap,switch%20to%20a%20new%20observable))**。例えばオートコンプリート入力の例では、ユーザーのタイプするたびに前の検索リクエストをキャンセルして新しいリクエストだけを採用する、という動きを`switchMap`で実現できます。内部実装としては、`source`から値を受け取るとまず現在アクティブな inner Observable の Subscription（もしあれば）に対して`unsubscribe()`を呼び、続いて新たな inner Observable を生成して購読を開始します ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=,any%20pending%20pushes))。これにより古いリクエストなど「古い内部ストリーム」は**途中でも停止**し、最新のストリームに“スイッチ”する動作になります。要するに、**常に一つの内部 Observable（最新のもの）だけをアクティブに保つ**のが switchMap です。【mergeMap との違い】: switchMap は古いものをキャンセルして切り替えるのに対し、mergeMap は前の Observable もキャンセルせず**全て並行して処理**します ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=,any%20pending%20pushes)) ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=For%20instance%2C%20when%20using%20switchMap,73%20is%20a%20better%20option))。そのため、**switchMap は「最新データ以外不要」なケースに、mergeMap は「全てのデータ（複数の非同期処理結果）を逃さず処理」したいケースに適しています**。

各オペレーターの内部実装を見ると、いずれも**Observable を入力として新たな Observable を返す高階関数**である点は共通しています。`pipe`を使った場合、RxJS は**各オペレーターを順に適用して新たな Observable を生成し、連続する Observable（前の Observable が発行した値を受け取る次の Observable）のチェーン**を作ります ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1.%20of%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6Observable%E3%81%8C%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%202.%20Observable.pipe%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%60%28Observable%29%20%3D,%E3%81%9D%E3%82%8C%E3%82%92subscirbe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E9%80%A3%E7%B6%9A%E3%81%97%E3%81%9FObservable%E3%81%AE%E5%87%A6%E7%90%86%E3%81%8C%E7%99%BA%E7%81%AB%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82))。例えば`source$.pipe(map(...), filter(...))`では、まず`source$`に`map`を適用した Observable が作られ、次にそれに対して`filter`を適用した Observable が作られる、という流れです。それぞれの内部で`source$`に`subscribe`し、データを加工して次に渡す処理が実装されています。特に`mergeMap`や`switchMap`などの flattening オペレーターは**「外側の Observable（ソース）と内側の Observable」を扱い、外側からの制御で内側の購読を管理する**という特徴があります ([javascript - flatMap, mergeMap, switchMap and concatMap in rxjs? - Stack Overflow](https://stackoverflow.com/questions/49698640/flatmap-mergemap-switchmap-and-concatmap-in-rxjs#:~:text=These%20operators%20are%20all%20transformation,observable%20controls%20the%20inner%20observable))。言い換えれば、高階 Observable を扱うオペレーターは**外側のストリームが内側ストリームを開始・停止するロジック**を内部に持っており、mergeMap は停止しない（全て走らせる）、switchMap は都度停止する、といった違いが実装上表現されています。

## 3. 非同期処理（Promise との違い、スケジューラの仕組み）

**Promise と Observable の違い:** Promise は一度きりの非同期結果を表し、そのインスタンス作成時に処理が開始されて最終的に単一の値かエラーを返します。一方、Observable は 0 個以上の値を時間をかけて順次返すことができ、`subscribe()`を呼ぶまで処理が開始されない遅延実行（lazy）という性質を持ちます ([angular - What is the difference between Promises and Observables? - Stack Overflow](https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables#:~:text=Promise%20,will%20either%20reject%20or%20resolve))。まとめると、**Promise は「単一の将来の値」を即時実行で提供しキャンセルできない**のに対し、**Observable は「複数の将来の値」を遅延実行で提供し購読解除でキャンセル可能**です ([angular - What is the difference between Promises and Observables? - Stack Overflow](https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables#:~:text=Promise%20,will%20either%20reject%20or%20resolve))。また、Observable は`map`や`filter`などの**豊富な演算子を使ってストリーム操作ができる**点でも Promise より強力です ([angular - What is the difference between Promises and Observables? - Stack Overflow](https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables#:~:text=Promise%20,will%20either%20reject%20or%20resolve))。例えば Promise では then チェーンで逐次処理を書くところを、Observable では`pipe`で直列・並列含め柔軟に非同期処理を組み合わせることができます。

**Scheduler（スケジューラ）の仕組みと役割:** RxJS の Scheduler は**Observable の通知（next, error, complete）をどの実行コンテキストでいつ実行するか**を決定する仕組みです ([RxJS Schedulers - DEV Community](https://dev.to/this-is-learning/rxjs-schedulers-2fhl#:~:text=,C%29%20RxJS%20Documentation))。JavaScript における実行コンテキストとは、具体的には:

- **同期的実行**（現在のコールスタック上で即時実行）
- **マイクロタスク**（Promise の then や`process.nextTick`など、現在のタスク終了後ただちに実行）
- **マクロタスク**（`setTimeout`や`setInterval`、DOM イベントなど次のイベントループサイクルで実行）
- **描画フレーム**（ブラウザのレンダリング前のタイミングで実行、`requestAnimationFrame`）

RxJS ではこれらに対応する複数種類の Scheduler が提供されています ([RxJS Schedulers - DEV Community](https://dev.to/this-is-learning/rxjs-schedulers-2fhl#:~:text=In%20browser%20code%20executes%20in,following%20order)) ([RxJS Schedulers - DEV Community](https://dev.to/this-is-learning/rxjs-schedulers-2fhl#:~:text=%2A%20%60queueScheduler%60%20,animation%20frame)):

- **`queueScheduler`** – 同期実行（キューに入れられたタスクを現在の call stack 内で順次実行）。即時スケジューリングに使われます。
- **`asapScheduler`** – マイクロタスクとして実行。内部的に Promise や`process.nextTick`を利用し、可能な限り早いタイミングで非同期実行します ([Rxjs Scheduler: What's the difference between asap and async? - Stack Overflow](https://stackoverflow.com/questions/47377245/rxjs-scheduler-whats-the-difference-between-asap-and-async#:~:text=From%3A%20Randall%20Koutnik%20Book%20%E2%80%9CBuild,%E2%80%9D))。
- **`asyncScheduler`** – マクロタスクとして実行。`setTimeout`を用いてスケジューリングするため、指定時間の遅延実行やインターバル実行に使われます ([Rxjs Scheduler: What's the difference between asap and async? - Stack Overflow](https://stackoverflow.com/questions/47377245/rxjs-scheduler-whats-the-difference-between-asap-and-async#:~:text=From%3A%20Randall%20Koutnik%20Book%20%E2%80%9CBuild,%E2%80%9D))。
- **`animationFrameScheduler`** – ブラウザの次の**描画タイミングで実行**します。アニメーション更新などに適しています。

これらを使うと、例えば`of(1,2,3, queueScheduler)`のように Observable の演算子や作成関数に Scheduler を指定することで、通知のタイミングを制御できます。デフォルトでは多くの Observable は**同期的**に動作します（例: `of`や`from`は即座に値を送出）が、`observeOn`や`subscribeOn`といった演算子や`interval`/`timer`等は内部で Scheduler を用いて非同期的に動作します ([RxJS Schedulers - DEV Community](https://dev.to/this-is-learning/rxjs-schedulers-2fhl#:~:text=In%20browser%20code%20executes%20in,following%20order))。Scheduler を明示的に指定すれば、どのコンテキストで実行するか（例えば UI スレッドをブロックしないよう`asyncScheduler`で非同期にする等）を調整できます。

**Promise との非同期実行の違い:** JavaScript では Promise の`then`コールバックは常にマイクロタスクキューで実行されますが、Observable は Scheduler 次第で**同期実行も非同期実行も可能**です。例えば Scheduler に何も指定しなければ`observable.subscribe()`内の処理は直ちに（同期的に）実行されますが、`observeOn(asyncScheduler)`を挟めばその後の処理は非同期タスクとしてスケジュールされます。RxJS はこのように**実行タイミングを細かく制御できる柔軟性**があります。

**Scheduler とマルチスレッド:** RxJS の Scheduler はあくまで単一スレッド上でのタスクスケジューリングであり、スレッドそのものを増やすわけではありません。ブラウザや Node.js のイベントループ上でタスクの実行順序を調整するもので、例えば`asyncScheduler`は`setTimeout`（ブラウザでは厳密には Web API）にタスクを委ねます。したがって RxJS 自体は**シングルスレッド上で非同期処理を実現するライブラリ**です。複数の Scheduler を使っても JavaScript のメインスレッド上で順序よく処理されるだけで、並列スレッドで同時に実行されるわけではありません（同一時間に並行して進むように見えても実際はタスクが順番に実行されている）。もし実際にマルチスレッド（Web Workers など）を使いたい場合は、RxJS とは別にワーカーを起動しメッセージを Observable 化するなどのアプローチが必要です。

## 4. メモリ管理とパフォーマンス（購読解除、メモリリーク対策）

RxJS を使う上で重要なことの一つに、**不要になった購読をきちんと解除してメモリリークを防止する**ことがあります。特に Angular など長時間動作するアプリケーションでは、購読しっぱなしの Observable が蓄積するとメモリ消費や不要な処理の実行につながります。

**購読解除の仕組み（unsubscribe）:** 前述のとおり、`Subscription.unsubscribe()`を呼ぶとその購読に関連するリソースが全てクリーンアップされます ([What is .subscribe in Angular? - Stack Overflow](https://stackoverflow.com/questions/44921788/what-is-subscribe-in-angular#:~:text=A%20Subscription%20is%20an%20object,Subscription%20has%20one%20important))。例えば`setInterval`で定期実行していた処理であれば`clearInterval`が内部で呼ばれ、DOM イベントを監視していた場合はイベントリスナーが解除されます。RxJS の Subscription は子 Subscription を持つ場合もあり（例えば`mergeMap`で生成された内部購読など）、親の`unsubscribe()`を呼ぶと**子の Subscription も再帰的に解除**される実装になっています。これにより開発者は個別の購読をいちいち管理しなくても、まとめて購読解除を行えるようになっています ([RxJS Scheduler について](https://tech.bitbank.cc/about-rxjs-scheduler/#:~:text=Action%E3%81%AF%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B%E5%87%A6%E7%90%86%E3%81%AE%E4%B8%80%E3%81%A4%E4%B8%80%E3%81%A4%E3%82%92%E4%BB%A3%E8%A1%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%81%9D%E3%81%97%E3%81%A6%E9%9D%A2%E7%99%BD%E3%81%84%E3%81%93%E3%81%A8%E3%81%ABAction%E3%81%AFSubscription%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%20%E3%81%A4%E3%81%BE%E3%82%8A%E3%80%81%E9%81%85%E5%BB%B6%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B%E5%87%A6%E7%90%86%E3%82%92%20,%E3%81%A7%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E5%BE%8C%E7%89%87%E4%BB%98%E3%81%91%E5%87%A6%E7%90%86%E3%81%8C%E5%87%BA%E6%9D%A5%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。

**メモリリークの主な原因:** メモリリークとは本来不要になったオブジェクトがガベージコレクトされずに残り続ける現象です。RxJS において典型的な原因は「**Observable の購読を解除し忘れる**」ことです ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Let%20me%20start%20off%20by,short%20lived%20observable%2C%20you%20don%E2%80%99t))。特に**「自然完了しない Observable」を購読した場合**は注意が必要です ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=A%20long%20lived%20observable%20is,potential%20to%20create%20memory%20leaks))。例えば`interval()`や`fromEvent()`が生成する Observable は明示的に`unsubscribe()`しない限り延々と値を出し続けます。このような**長命な Observable（long-lived observable）**をコンポーネントなどで購読したまま破棄すると、そのコンポーネントは既に画面上存在しなくても Observable の通知を受け取ろうとしてメモリ上に残り続けます ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=A%20long%20lived%20observable%20is,potential%20to%20create%20memory%20leaks))。逆に`of()`や`HttpClient`のように**有限の値を出して完了する Observable**は自動で完了(`complete`)まで到達し、その時点で購読も完了扱いとなるため、それ以上メモリを消費し続けることはありません ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=,short%20lived%20observable)) ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Another%20important%20example%20is%20Angular%E2%80%99s,easily%20test%20this%20for%20yourself))。Angular の HttpClient が返す Observable は 1 回レスポンスを受け取ると`complete`するため、購読解除しなくても問題になりにくいのはこのためです ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Another%20important%20example%20is%20Angular%E2%80%99s,easily%20test%20this%20for%20yourself)) ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=This%20is%20also%20the%20reason,there%20ARE%20no%20memory%20leaks))。

もう一つのメモリリーク要因は**Subject の不適切な使用**です。Subject 自体はマルチキャスト（複数の Observer に値を流す）に便利な仕組みですが、例えばコンポーネント間のイベントバスとしてグローバルな Subject を使いっぱなしにしていると、購読者リストがどんどん増えていってしまう恐れがあります。特に Subject を完了(`complete`)させずにアプリケーション全体で使い回すと、不要になった購読者がいつまでもリストに残りうるため注意が必要です。開発者側で Subject を利用する際は、適切なタイミングで`complete()`を呼ぶか、もしくは購読側で`takeUntil`などを使って完了させるなどの対策が求められます。**Hot な Observable（Subject など）**は自動完了しないため、メモリ管理に気を配る必要があります。

**メモリ最適化テクニックとベストプラクティス:**

- **確実に購読解除する:** コンポーネントが破棄される際（Angular なら`OnDestroy`）、そのコンポーネント内で開始した購読をすべて`unsubscribe()`するようにします。手動で Subscription を管理するほか、Angular では`AsyncPipe`を使えばテンプレートで自動的に購読・解除が行われるため非常に便利です ([An Introduction to RxJs and NgRx - DEV Community](https://dev.to/paulmojicatech/an-introduction-to-rxjs-and-ngrx-59nh#:~:text=,when%20the%20component%20is%20destroyed))。AsyncPipe はコンポーネント破棄時に自動で`unsubscribe`するため、メモリリーク防止になります。

- **オペレーターで購読を自動完了させる:** RxJS には一定の条件で自動的に完了させる演算子が多数あります。例えば**`take(n)`**は指定した回数だけ値を受け取ると自動的に`complete`しますし、**`takeUntil(notifier$)`**は`notifier$`が何か値を発したタイミングで完了させます。Angular では`OnDestroy`で`next`+`complete`する`Subject`（いわゆる DestroyNotifier）を用意し、`takeUntil`でコンポーネントのライフサイクルと Observable 購読を紐付けるパターンが一般的です。これにより所定のタイミングで確実に購読を終了できます。

- **長寿命の Observable を避けるか統合する:** 可能であれば`interval`や`fromEvent`で得た永続的な Observable をコンポーネント内で直接持たず、必要なデータだけ`pipe(..., takeUntil(...))`などで絞って使うようにします。また、`mergeMap`などで内部に長寿命の Observable を作る場合、内部でも`takeUntil`や`takeWhile`等で適切に完了させたり、`mergeMap`の代わりに`switchMap`（古いものをキャンセル）を使う選択肢もあります。例えば**`mergeMap`は複数の内部購読を同時に保持するため、inner Observable が長期間続くとその分メモリを占有し続ける**可能性があります ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=be%20maintained%20concatMap%20is%20a,better%20option))。そのような場合、`take`や`takeUntil`で inner を終了させるか、必要に応じて`switchMap`への置き換えを検討します ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=be%20maintained%20concatMap%20is%20a,better%20option))。

- **shareReplay の注意点:** 複数の遅延購読者のために`shareReplay`を使って Observable をマルチキャストするときは、デフォルトではキャッシュが残り続けるためメモリリークの原因になることがあります ([To unsubscribe, or not to unsubscribe, that is the question.](https://jaywoz.medium.com/rxjs-when-to-unsubscribe-c6f39b8b95b7#:~:text=RxJS%20is%20all%20about%20Subscriptions,lead%20to%20minor%20memory%20leaks))。`shareReplay({refCount: true, ...})`オプションで購読者が 0 になったら自動で解除する設定にするなど、キャッシュ系オペレーターの使い方にも注意します。

以上のように、RxJS では**「自動で完了しないものは自前で完了させる」**という方針が重要です。幸い Angular 環境では AsyncPipe や`HttpClient`の性質上、開発者が明示的に`unsubscribe`しなくても問題にならないケースも多々あります ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=This%20is%20also%20the%20reason,there%20ARE%20no%20memory%20leaks))。しかし Timer やイベントなど**常に動き続ける Observable**を使う際は、意識的に購読終了させるコードを書かなければメモリリークに繋がることを念頭に置いておきましょう。

## 5. 実践的な使い方（Angular での適用、NgRx との組み合わせ）

**Angular における RxJS 活用:** Angular では RxJS が広範に利用されています。たとえば`@angular/common/http`の**HttpClient**は HTTP リクエストの結果を Promise ではなく Observable で返します。`HttpClient.get()`などの各メソッドは**RxJS の Observable を返し、購読（subscribe）されると HTTP リクエストを送信し、レスポンスを受け取ると値を emit して完了する**ようになっています ([Making requests • Angular](https://angular.dev/guide/http/making-requests#:~:text=,results%20when%20the%20server%20responds))。HttpClient から返される Observable は**一度だけ値を発して自動的に complete される**（すなわち**単一値のコールド Observable**）ため、通常は手動で`unsubscribe`する必要はありません ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Another%20important%20example%20is%20Angular%E2%80%99s,easily%20test%20this%20for%20yourself))。例えば以下のコードは Angular での HTTP リクエストの典型例です:

```typescript
this.http.get<Data>('/api/data')
  .pipe(
    map(res => res.value),       // 必要に応じてデータ変換
    catchError(err => { ... })  // エラーハンドリング
  )
  .subscribe(value => {
    console.log('取得した値:', value);
  });
```

上記のように、`pipe`で RxJS オペレーターを使ってレスポンスデータの加工やエラー処理を直列に記述できます。Angular の HttpClient + RxJS により、従来 Promise で行っていた逐次処理も、Observable のストリーム処理として統一的に扱えるメリットがあります。さらに、コンポーネント側でこの Observable を扱う場合は、直接`subscribe`して値をセットする以外にも、テンプレートで AsyncPipe を使って非同期データをバインドすることができます。AsyncPipe を使うと購読と表示更新、解除が簡潔に書け、メモリリークの心配も減るため Angular では推奨されるパターンです ([An Introduction to RxJs and NgRx - DEV Community](https://dev.to/paulmojicatech/an-introduction-to-rxjs-and-ngrx-59nh#:~:text=,when%20the%20component%20is%20destroyed))。

**フォームやイベントとの連携:** Angular のフォーム（Reactive Forms）では`FormControl.valueChanges`が Observable として提供されており、ユーザ入力の変化を RxJS でストリームとして扱えます。また、`fromEvent(element, 'click')`のように DOM イベントを Observable 化して扱うことも可能です。これにより、**イベントハンドリングやフォーム入力処理をストリームとしてリアクティブに組み立てられる**利点があります。例えば、テキストボックスの入力値に応じて API 検索を行い結果を表示する場合、RxJS を用いれば`valueChanges.pipe(debounceTime(300), switchMap(...))`のように「300ms 入力が止まるごとに最新入力で検索し、古い検索結果はキャンセルする」といった実装が数行で可能です。このような**非同期処理の組み合わせ・制御**は RxJS の真価が発揮される部分です。

**NgRx における RxJS の活用:** NgRx は Angular 向けの状態管理ライブラリで、Redux パターンを実現します（NgRx の「Ng」は Angular、「Rx」は RxJS を指します ([An Introduction to RxJs and NgRx - DEV Community](https://dev.to/paulmojicatech/an-introduction-to-rxjs-and-ngrx-59nh#:~:text=Enter%20NgRx,in%20a%20moment%20of%20time))）。NgRx ストア(Store)やエフェクト(Effects)の仕組みは RxJS の Observable を基盤として構築されています。主な NgRx の要素は**Actions（アクション）**・**Reducers（リデューサー）**・**Store（ストア）**・**Effects（エフェクト）**・**Selectors（セレクタ）**ですが、このうち特に**Effects**と**Store**で RxJS が大きく関与します。

- **Effects**: エフェクトは Redux でいうところのミドルウェア/サイドエフェクト処理を担いますが、その実体は**Action の Observable に対する RxJS のパイプライン**です。NgRx の`@ngrx/effects`では、全てのアクションは`Actions`という Observable ストリーム（マルチキャストされた Hot Observable）として提供されます。エフェクトはこの Actions ストリームに対して`ofType(...)`で特定のアクションをフィルタし、`switchMap`や`mergeMap`で非同期処理（例えば HttpClient での API 呼び出しなど）を行い、その結果を新たな Action として`return`する流れで実装します。【Effects の公式説明】: 「Effects は Store のための RxJS による副作用モデルであり、ストリームを用いて外部とのやりとりから新たなアクションを Dispatch します」 ([Effects - NgRx](https://v7.ngrx.io/guide/effects#:~:text=Effects%20are%20an%20RxJS%20powered,state%20based%20on%20external%20interactions))。例えばログイン処理の Effect は擬似コードで次のようになります:

  ```typescript
  login$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AuthActions.login), // 「ログイン」アクションのみを処理
      mergeMap((action) =>
        this.http.post("/api/login", action.credentials).pipe(
          map((user) => AuthActions.loginSuccess({ user })), // 成功時は成功アクションへ
          catchError((error) => of(AuthActions.loginFailure({ error })))
        )
      )
    )
  );
  ```

  上記のように、Effect では**アクションの Observable に対し RxJS 演算子で非同期処理を記述し、その最終結果として別のアクションを流す**ことで、非同期処理と状態遷移を結びつけています。`switchMap`と`mergeMap`の使い分けも重要で、例えばユーザー検索のように「古いリクエストはキャンセルして最新結果のみ使う」場合は`switchMap`、ファイルアップロードのように「全てのリクエストを完了させる」場合は`mergeMap`を使うなど、RxJS の知見がそのまま Effect 実装の質につながります。

- **Store と Selectors**: NgRx の Store はアプリケーション状態そのものを保持し、これは**Observable として露出**しています。`store.select(selector)`を呼ぶと、そのセレクタで抽出した状態スライスを表す Observable が返されます ([Here's how NgRx selectors actually work internally - DEV Community](https://dev.to/davidshortman/heres-how-ngrx-selectors-actually-work-internally-15ml#:~:text=How%20))。コンポーネントでは`this.store.select(...).subscribe(...)`としたり、テンプレートで`| async`を使ってこの Observable から状態を取得します。**Store は単なる Observable**ですので、コンポーネント側では通常の Observable と同様に`pipe`で演算子を使ったり、複数の`select`結果を`combineLatest`するなどして状態を加工できます。Selectors 自体は純粋関数ですが、NgRx 内部では`store.select`が状態更新ごとに該当セレクタを適用し、新しい値があれば通知する Observable を返す仕組みになっています ([Here's how NgRx selectors actually work internally - DEV Community](https://dev.to/davidshortman/heres-how-ngrx-selectors-actually-work-internally-15ml#:~:text=How%20))。これは内部的に`map`や`distinctUntilChanged`を使って実装されており、重複した同じ状態値は通知しないなどの最適化も行われます ([Here's how NgRx selectors actually work internally - DEV Community](https://dev.to/davidshortman/heres-how-ngrx-selectors-actually-work-internally-15ml#:~:text=class%20Store,))。このように**Store から得られる各種状態は全て Observable**であり、RxJS の操作が可能です。

NgRx を用いることで、コンポーネントは副作用のある処理を直接持たず Actions を発行するだけ、実際の非同期処理は Effects（＝ RxJS ストリーム）に委ね、状態の反映は Store（＝ Observable）から購読するだけ、という**完全なリアクティブパターン**を実現できます。これは大規模アプリケーションでの一貫性や可読性、テスト容易性に寄与します。開発者にとっては、**RxJS の高度なストリーム処理の知識がそのまま NgRx の効果的な利用に直結する**と言えます。例えば`switchMap`で直前の HTTP 要求をキャンセルする実装や、`combineLatest`で複数の Store セレクタを組み合わせてビュー Model を作る実装など、RxJS の組み合わせ技によって複雑な非同期ロジックも宣言的に書くことが可能です。

## 6. RxJS の内部実装（ストリーム処理や購読処理の実装）

最後に、以上の動作原理を支える**RxJS ライブラリの内部実装**について、高レベルで押さえておきます。

**データの流れと購読処理:** RxJS では、Observable の`pipe`チェーンによって**一連の Observable が連結**します ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1.%20of%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6Observable%E3%81%8C%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%202.%20Observable.pipe%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%60%28Observable%29%20%3D,%E3%81%9D%E3%82%8C%E3%82%92subscirbe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E9%80%A3%E7%B6%9A%E3%81%97%E3%81%9FObservable%E3%81%AE%E5%87%A6%E7%90%86%E3%81%8C%E7%99%BA%E7%81%AB%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82))。各演算子は「前の Observable を入力とし、新しい Observable を返す関数」であり、例えば`source$.pipe(map(...), filter(...))`というチェーンは内部的に以下のように動作します ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1.%20of%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6Observable%E3%81%8C%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%202.%20Observable.pipe%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%60%28Observable%29%20%3D,%E3%81%9D%E3%82%8C%E3%82%92subscirbe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E9%80%A3%E7%B6%9A%E3%81%97%E3%81%9FObservable%E3%81%AE%E5%87%A6%E7%90%86%E3%81%8C%E7%99%BA%E7%81%AB%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82)):

1. `of`や`from`などで最初の`source$`（Observable）が作られる。
2. `pipe`内で順番に各オペレーター関数が実行される。それぞれ**`(Observable) => Observable`な関数**であり、引数に直前の Observable を受け取り、新たな Observable（次の演算子にデータを渡す Observable）を生成する ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1.%20of%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6Observable%E3%81%8C%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%202.%20Observable.pipe%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%60%28Observable%29%20%3D,%E3%81%9D%E3%82%8C%E3%82%92subscirbe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E9%80%A3%E7%B6%9A%E3%81%97%E3%81%9FObservable%E3%81%AE%E5%87%A6%E7%90%86%E3%81%8C%E7%99%BA%E7%81%AB%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82))。この時点で**演算子ごとの新たな Observable が連続して繋がったチェーン**が構成される。
3. `pipe`の結果として最後の演算子まで適用済みの Observable が返される。
4. 最終的に`subscribe()`が呼ばれると、この連続した Observable チェーンに対して購読が開始される ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=3))。具体的には、一番最後の Observable の`subscribe`が呼ばれると、それが内部でひとつ上流の Observable に対して`subscribe`を呼び…という処理が再帰的に行われ、**ソース Observable まで遡って購読が開始**されるイメージです ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=3))。その結果、ソースから値が発行されると各演算子を通過して最終的な Observer に届く経路が出来上がります。

言い換えると、**`subscribe`の呼び出しは Observable チェーン全体に波及し、ソース → 演算子 →…→ 最終 Observer というデータ経路を初期化する**トリガーです ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=3))。各演算子はそれぞれ自分の上流 Observable を購読しつつ、下流 Observer に対して値を転送する`Subscriber`（Observer を拡張したもの）を内部に持っています。例えば`map`オペレーターの内部実装は以下のような擬似コードで表せます ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=%2F%2F%20source.subscribe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7of%E3%81%AE%E5%80%A4%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%20source.subscribe%28%20operate%28,)):

```typescript
function map(projectFn) {
  return (source) =>
    new Observable((destinationObserver) => {
      // sourceを購読
      source.subscribe({
        next: (value) => {
          // project関数で変換し、destinationに通知
          destinationObserver.next(projectFn(value));
        },
        error: (err) => destinationObserver.error(err),
        complete: () => destinationObserver.complete(),
      });
    });
}
```

実際の RxJS では`Subscriber`や`operate`ユーティリティを使ってもう少し抽象化されていますが、本質的には**各演算子は上流から受け取った`next`を加工して下流の Observer に`next`し、`error`と`complete`は原則ストレートに伝搬させる**処理を行っています ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=%2F%2F%20source.subscribe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7of%E3%81%AE%E5%80%A4%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%20source.subscribe%28%20operate%28,)) ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=export%20function%20operate,destination%2C%20subscriberOverrides%29%3B))。`filter`であれば`next`時に条件分岐を設けて必要な時だけ`destination.next(...)`を呼ぶように実装されますし、`map`であれば上記のように変換して渡すだけです。

**mergeMap や switchMap の内部処理:** flattening 系演算子は内部で**複数の内部 Observable を管理**するロジックが加わります。`mergeMap`の場合、上流の`next`が来るたびに`project`関数で inner Observable を作成して購読し、その Subscription をリストに保持します。inner から値が来れば即座に下流 Observer に流し、全ての inner が完了したら自分も完了する、といった制御をします。複数の inner が同時進行する点以外は単純な転送の繰り返しなので実装自体は直感的です。一方`switchMap`は inner を一つだけしか持たないように制御する点が特徴です。内部的には現在アクティブな inner Subscription をプロパティ（例えば`this.innerSub`）として持ち、新しい値が来た際にはそれが非 null かチェックして**存在すれば`this.innerSub.unsubscribe()`で前の購読を停止**します ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=,any%20pending%20pushes))。そして新たな inner Observable を購読し、その Subscription を`this.innerSub`に差し替えます。このようにして**常に最新の購読だけが生きている状態を保つ**のです ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=,any%20pending%20pushes))。実装上は if 文で現在の購読を解除しているだけですが、結果として前のリクエスト等はキャンセルされる挙動になります。

なお、どちらの演算子も Outer（外側）Observable が`complete`した際や、全体が`unsubscribe`された際には**保持している inner の Subscription を全て解除**するように実装されています。これは RxJS 全般のポリシーで、たとえ複数の内部購読があっても一括で管理し終了できるようになっています（内部で`subscription.add(innerSub)`として紐付け、まとめて解除） ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=12.%2012%20,in%20RxJS%202m%208s))。したがって`switchMap`や`mergeMap`をネストしていても、最終的にトップレベルの`unsubscribe()`を呼べばツリー上の全ての購読がクリーンアップされます。

**その他の実装トピック:** RxJS 内部にはここで紹介した以外にも様々な工夫があります。例えば、`Subject`は特殊な Observable でありつつ Observer でもある（二重の役割を持つ）ため、Subscribed 時の挙動が通常の Observable と異なります。具体的には Subject に購読しても内部で新たな実行は開始されず、Subject が保持するリスナーリストに Observer が追加されるだけです ([RxJS 公式 Overview 要約(備忘録) #JavaScript - Qiita](https://qiita.com/UHNaKZ/items/1d0f1bc2dd0b4f539d1d#:~:text=%E5%86%85%E9%83%A8%E5%AE%9F%E8%A3%85%E3%81%AE%E8%A9%B1%E3%82%92%E3%81%99%E3%82%8B%E3%81%A8%20Subject%20%E3%81%AB%E3%81%9F%E3%81%84%E3%81%99%E3%82%8B%E8%B3%BC%E8%AA%AD%E3%81%AF%E5%80%A4%E3%82%92%E5%B1%8A%E3%81%91%E3%82%8B%E6%96%B0%E3%81%97%E3%81%84%E5%AE%9F%E8%A1%8C%E3%82%92%E5%A7%8B%E3%82%81%E3%81%AA%E3%81%84%E3%80%82%E9%80%9A%E5%B8%B8%E3%81%AE%20AddListner%20%E3%81%AA%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E8%B3%BC%E8%AA%AD%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%99%E3%82%8B%E3%81%A0%E3%81%91%E3%81%A7%E3%81%82%E3%82%8B,))。これは**hot Observable**の特性で、Subject は自らデータを発行する主体であるためです。また、Scheduler については**遅延実行を可能にするために Action（スケジュールされた作業）も Subscription の一種として実装**されており、unsubscribe でタイマーをキャンセルできるようになっています ([RxJS Scheduler について](https://tech.bitbank.cc/about-rxjs-scheduler/#:~:text=Action%E3%81%AF%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B%E5%87%A6%E7%90%86%E3%81%AE%E4%B8%80%E3%81%A4%E4%B8%80%E3%81%A4%E3%82%92%E4%BB%A3%E8%A1%A8%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E3%81%9D%E3%81%97%E3%81%A6%E9%9D%A2%E7%99%BD%E3%81%84%E3%81%93%E3%81%A8%E3%81%ABAction%E3%81%AFSubscription%E3%81%A7%E3%82%82%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%20%E3%81%A4%E3%81%BE%E3%82%8A%E3%80%81%E9%81%85%E5%BB%B6%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B%E5%87%A6%E7%90%86%E3%82%92%20,%E3%81%A7%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E5%BE%8C%E7%89%87%E4%BB%98%E3%81%91%E5%87%A6%E7%90%86%E3%81%8C%E5%87%BA%E6%9D%A5%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))。細かな点では、RxJS v7 で`lift`という内部メソッドが非推奨化されるなど、パフォーマンスやメンテナンス性のために内部構造の変更も行われています。

以上、RxJS の基本概念から内部実装までを概観しました。**まとめると、RxJS は「データストリーム」を表す Observable と Observer パターンを核に、各種演算子でストリームを自在に変換・結合し、Scheduler で実行タイミングを制御するライブラリ**です。その内部は意外とシンプルな仕組みの組み合わせですが、これを駆使することで高度な非同期処理を宣言的かつ効率的に記述できます。RxJS の本質的な動作原理を理解すると、Angular アプリケーションや NgRx を用いた状態管理で発生する複雑な非同期シナリオにも適切に対処できるようになります。ぜひこれらの知識を活かして、より優れた非同期処理の設計と実装に挑戦してください。

**References:**

1. Vitainbeta - _Hands-on: Create an Observable_ ([Hands-on-1: Create an Observable - vitainbeta](https://www.vitainbeta.org/hands-on-1-create-an-observable/#:~:text=Remember%20that%20an%20Observable%20delivers,of%20notifications%20to%20the%20Observer)) ([Hands-on-1: Create an Observable - vitainbeta](https://www.vitainbeta.org/hands-on-1-create-an-observable/#:~:text=Every%20time%20we%20call%20%C2%A0,dev))
2. Qiita - _RxJS 公式 Overview 要約_ ([RxJS 公式 Overview 要約(備忘録) #JavaScript - Qiita](https://qiita.com/UHNaKZ/items/1d0f1bc2dd0b4f539d1d#:~:text=const%20observer%20%3D%20,h%28%29%2C%2F%2Fsubscribe%E3%81%8C%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E6%99%82%E3%81%AE%E5%87%A6%E7%90%86)) ([RxJS 公式 Overview 要約(備忘録) #JavaScript - Qiita](https://qiita.com/UHNaKZ/items/1d0f1bc2dd0b4f539d1d#:~:text=))
3. Stack Overflow - _What is the difference between Promises and Observables?_ ([angular - What is the difference between Promises and Observables? - Stack Overflow](https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables#:~:text=Promise%20,will%20either%20reject%20or%20resolve))
4. RxJS Learn - _map operator_ ([map - RxJS](https://rxjs.dev/api/operators/map#:~:text=Similar%20to%20the%20well%20known,projection%20in%20the%20output%20Observable))
5. Stackademic Blog - _RxJS Transformation Operators_ ([RxJS Transformation Operators' Implementation | by Amit Dhiman | Stackademic](https://blog.stackademic.com/rxjs-transformation-operators-implementation-36dddf3ba7d9#:~:text=In%20this%20example%2C%20we%20use,that%20satisfy%20the%20filtering%20condition))
6. Learn RxJS - _mergeMap vs other mapping operators_ ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=For%20instance%2C%20when%20using%20switchMap,73%20is%20a%20better%20option)) ([mergeMap / flatMap | Learn RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#:~:text=be%20maintained%20concatMap%20is%20a,better%20option))
7. Clear Blue Design - _switchMap description_ ([Simple Angular Debounce using RxJS | Clear Blue Design](https://m.clearbluedesign.com/how-to-simple-angular-debounce-using-rxjs-e7b86fde6167#:~:text=%3E%20switchMap,switch%20to%20a%20new%20observable))
8. Egghead - _switchMap inner subscription cancellation_ ([Implement RxJS `switchMap` by Canceling Inner Subscriptions as Values are Passed Through | egghead.io](https://egghead.io/lessons/rxjs-implement-rxjs-switchmap-by-canceling-inner-subscriptions-as-values-are-passed-through#:~:text=,any%20pending%20pushes))
9. JDriven Blog - _RxJS - When and how to unsubscribe_ ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Let%20me%20start%20off%20by,short%20lived%20observable%2C%20you%20don%E2%80%99t)) ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=A%20long%20lived%20observable%20is,potential%20to%20create%20memory%20leaks))
10. JDriven Blog - _Angular HttpClient completes_ ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=Another%20important%20example%20is%20Angular%E2%80%99s,easily%20test%20this%20for%20yourself)) ([RxJS - When and how to unsubscribe - JDriven Blog](https://jdriven.com/blog/2020/10/RxJS-when-and-how-to-unsubscribe#:~:text=This%20is%20also%20the%20reason,there%20ARE%20no%20memory%20leaks))
11. Angular Official Docs - _HttpClient guide_ ([Making requests • Angular](https://angular.dev/guide/http/making-requests#:~:text=,results%20when%20the%20server%20responds))
12. Dev.to - _AsyncPipe and cold observables_ ([An Introduction to RxJs and NgRx - DEV Community](https://dev.to/paulmojicatech/an-introduction-to-rxjs-and-ngrx-59nh#:~:text=,when%20the%20component%20is%20destroyed))
13. NgRx Docs (v7) - _Effects: streams of actions_ ([Effects - NgRx](https://v7.ngrx.io/guide/effects#:~:text=Effects%20are%20an%20RxJS%20powered,state%20based%20on%20external%20interactions))
14. Dev.to - _NgRx selectors and store.select_ ([Here's how NgRx selectors actually work internally - DEV Community](https://dev.to/davidshortman/heres-how-ngrx-selectors-actually-work-internally-15ml#:~:text=How%20)) ([Here's how NgRx selectors actually work internally - DEV Community](https://dev.to/davidshortman/heres-how-ngrx-selectors-actually-work-internally-15ml#:~:text=class%20Store,))
15. Mashiro.js Blog - _RxJS の実装から読み解くストリーム_ ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=1.%20of%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6Observable%E3%81%8C%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82%202.%20Observable.pipe%E3%81%8C%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%60%28Observable%29%20%3D,%E3%81%9D%E3%82%8C%E3%82%92subscirbe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E9%80%A3%E7%B6%9A%E3%81%97%E3%81%9FObservable%E3%81%AE%E5%87%A6%E7%90%86%E3%81%8C%E7%99%BA%E7%81%AB%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E9%96%A2%E6%95%B0%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%82%8B%E3%80%82)) ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=%2F%2F%20source.subscribe%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7of%E3%81%AE%E5%80%A4%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%20source.subscribe%28%20operate%28,)) ([RxJS の実装から読み解くストリーム](https://blog.mashirojs.net/posts/rxjs-implementation-of-stream/#:~:text=export%20function%20operate,destination%2C%20subscriberOverrides%29%3B))
16. Bitbank Tech Blog - _RxJS Scheduler について_
